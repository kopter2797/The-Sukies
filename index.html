<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Friend from Hell: The Sukies</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="icon" href="./img/logo_round.png" type="image/png" />
    <link
      href="https://fonts.googleapis.com/css2?family=Kanit:wght@400;600&family=Orbitron:wght@700;900&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --glow-cyan: rgba(0, 255, 255, 0.8);
        --glow-pink: rgba(255, 78, 222, 0.9);
        --bg-dark: #010410;
        --glass-bg: rgba(12, 23, 53, 0.55);
        --glass-border: rgba(42, 115, 255, 0.2);
        --text-primary: #e0e7ff;
        --text-secondary: #a5b4fc;
      }
      html {
        scroll-behavior: smooth;
      }
      body {
        font-family: "Kanit", "Poppins", sans-serif;
        background-color: var(--bg-dark);
        color: var(--text-primary);
        overflow-x: hidden;
      }
      .font-orbitron {
        font-family: "Orbitron", sans-serif;
      }
      #starfield-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
      }
      body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        box-shadow: inset 0 0 15vw rgba(1, 4, 16, 0.8);
        z-index: 1;
      }
      .screen-container {
        position: fixed;
        inset: 0;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        width: 100%;
        height: 100dvh;
        transition: opacity 0.5s ease-out;
      }
      .screen-container.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .glass-ui {
        background: var(--glass-bg);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
      }
      .text-glow {
        text-shadow: 0 0 8px var(--glow-cyan), 0 0 16px var(--glow-cyan),
          0 0 24px var(--glow-cyan);
      }
      .text-glow-pink {
        text-shadow: 0 0 8px var(--glow-pink), 0 0 16px var(--glow-pink);
      }
      .card-border-glow-enemy {
        border: 2px solid;
        border-image-slice: 1;
        border-image-source: linear-gradient(135deg, #ff416c, #ff4b2b);
      }
      .card-border-glow-player {
        border: 2px solid;
        border-image-slice: 1;
        border-image-source: linear-gradient(135deg, #00f260, #0575e6);
      }
      .btn-game {
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        color: var(--text-primary);
        background: linear-gradient(
          145deg,
          rgba(37, 47, 80, 0.8),
          rgba(20, 27, 51, 0.8)
        );
        border: 1px solid rgba(129, 140, 198, 0.3);
        border-radius: 0.5rem;
        padding: 0.75rem 1.5rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
        box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.1),
          0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .btn-game::before {
        content: "";
        position: absolute;
        top: 0;
        left: -80%;
        width: 50%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transform: skewX(-25deg);
        transition: left 0.7s ease;
      }
      .btn-game:hover {
        transform: translateY(-2px);
        border-color: rgba(165, 180, 252, 0.6);
        box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.1),
          0 4px 8px rgba(0, 0, 0, 0.5), 0 0 15px var(--glow-cyan);
      }
      .btn-game:hover::before {
        left: 120%;
      }
      .btn-game:active {
        transform: translateY(1px);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .bar-container {
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 9999px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 2px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
      }
      .bar-inner {
        height: 100%;
        border-radius: 9999px;
        transition: width 0.5s ease-in-out;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      }
      .hp-bar .bar-inner {
        background: #1e875a;
      }
      .energy-bar .bar-inner {
        background: #2a68a1;
      }
      .ultimate-bar .bar-inner {
        background: #b18e0f;
      }
      .bar-inner::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
          0deg,
          transparent 50%,
          rgba(255, 255, 255, 0.1) 50%
        );
        background-size: 100% 4px;
      }
      @keyframes modal-fade-in {
        from {
          opacity: 0;
          transform: translateY(20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      .modal-animate {
        animation: modal-fade-in 0.4s cubic-bezier(0.25, 1, 0.5, 1);
      }
      @keyframes card-warp-in {
        from {
          opacity: 0;
          transform: translateY(50px) scale(0.8);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      .card-warp-in-animate {
        animation: card-warp-in 0.5s ease-out backwards;
      }
      @keyframes card-glitch-out {
        0% {
          transform: scale(1);
          opacity: 1;
          filter: brightness(1);
        }
        20% {
          transform: translateX(5px);
          filter: brightness(2);
        }
        40% {
          transform: translateX(-5px);
          filter: saturate(2);
        }
        60% {
          transform: scale(1.05);
          opacity: 0.5;
        }
        80% {
          transform: scale(0.95) skew(-5deg);
          opacity: 0.3;
        }
        100% {
          transform: scale(0.8) translateY(20px);
          opacity: 0;
          filter: blur(5px);
        }
      }
      .card-glitch-out-animate {
        animation: card-glitch-out 0.7s ease-in-out forwards;
      }
      @keyframes ultimate-glow {
        0%,
        100% {
          box-shadow: 0 0 5px #f8d84a, 0 0 10px #f8d84a, 0 0 15px #f7b733;
        }
        50% {
          box-shadow: 0 0 10px #ffeb99, 0 0 20px #ffeb99, 0 0 30px #f7b733;
        }
      }
      .ultimate-bar .bar-inner.full {
        animation: ultimate-glow 2s infinite ease-in-out;
      }
      .taking-damage {
        animation: shake 0.4s;
      }
      @keyframes shake {
        0%,
        100% {
          transform: translate(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translate(-6px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translate(6px);
        }
      }
      .hit-effect {
        animation: hit-pop 1.5s ease-out forwards;
      }
      @keyframes hit-pop {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 1;
        }
        80% {
          transform: translate(-50%, -150%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -200%) scale(1.2);
          opacity: 0;
        }
      }
      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(0, 229, 255, 0.3);
        border-radius: 3px;
        border: 1px solid rgba(0, 229, 255, 0.5);
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 229, 255, 0.6);
      }
      .loader {
        border: 4px solid rgba(0, 229, 255, 0.2);
        border-top: 4px solid #ff4edf;
        border-radius: 50%;
        width: 64px;
        height: 64px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* --- New styles for character images --- */
      .char-image-wrapper {
        position: absolute;
        inset: 0;
        padding: 2px; /* Space for the gradient border */
        border-radius: 9999px; /* fully rounded */
        transition: all 0.3s ease;
      }
      .char-image-wrapper::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 9999px;
        padding: 2px; /* border thickness */
        background: linear-gradient(
          135deg,
          #00f260,
          #0575e6
        ); /* Player gradient */
        -webkit-mask: linear-gradient(#fff 0 0) content-box,
          linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
      }
      .char-image-wrapper.enemy::before {
        background: linear-gradient(
          135deg,
          #ff416c,
          #ff4b2b
        ); /* Enemy gradient */
      }
      .char-image-wrapper.player {
        box-shadow: 0 0 8px rgba(5, 117, 230, 0.6),
          0 0 16px rgba(0, 242, 96, 0.4);
      }
      .char-image-wrapper.enemy {
        box-shadow: 0 0 8px rgba(255, 75, 43, 0.6),
          0 0 16px rgba(255, 65, 108, 0.4);
      }
      .char-image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 9999px;
        background-color: var(--bg-dark); /* Fallback if image fails */
      }
      .selection-portrait:hover img {
        box-shadow: 0 0 15px var(--glow-cyan);
        transform: scale(1.03);
      }
      @keyframes screen-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-8px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(8px);
        }
      }

      .screen-shake-animate {
        animation: screen-shake 0.5s ease-in-out;
      }

      #ultimate-overlay.flash {
        background: radial-gradient(
          circle,
          rgba(255, 235, 150, 0.6) 0%,
          rgba(255, 100, 50, 0) 70%
        );
        opacity: 1;
        transition: opacity 0.4s ease-out;
      }
      #card-area.ultimate-active .card:not(.ultimate-focus) {
        filter: brightness(0.4) saturate(0.5);
        transform: scale(0.95);
      }
      .card.ultimate-focus {
        box-shadow: 0 0 25px var(--glow-pink), 0 0 40px var(--glow-cyan);
        transform: scale(1.05);
        z-index: 101;
      }
      /* Style for lives indicator */
      .lives-indicator {
        position: absolute;
        top: -5px;
        left: -5px;
        width: 28px;
        height: 28px;
        background-color: #ff416c;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Orbitron", sans-serif;
        font-weight: bold;
        font-size: 14px;
        border: 2px solid white;
        box-shadow: 0 0 8px rgba(255, 65, 108, 0.8);
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .lives-indicator.visible {
        opacity: 1;
      }
      /* --- Animation for Title's Transformation --- */
      .card.is-transforming .char-image-wrapper {
        animation: transform-glow 0.8s ease-in-out;
      }

      .card.is-transforming .char-image-wrapper img {
        transition: opacity 0.5s ease-in-out;
      }

      .card.is-transforming .char-image-wrapper .transformed-img {
        opacity: 1;
      }

      .char-image-wrapper .transformed-img {
        position: absolute;
        top: 0;
        left: 0;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      /* --- NEW Animation for Title's Transformation --- */
      .card.is-transforming {
        animation: transform-flicker 1.5s ease-in-out forwards;
      }

      .card.is-transforming .char-image-wrapper::before,
      .card.is-transforming .char-image-wrapper::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 9999px;
        z-index: 10;
      }

      .card.is-transforming .char-image-wrapper::before {
        animation: transform-static 1.5s steps(1) forwards;
        background-image: repeating-linear-gradient(
          0deg,
          rgba(255, 255, 255, 0.1) 0px,
          rgba(255, 255, 255, 0.1) 1px,
          transparent 1px,
          transparent 4px
        );
      }

      .card.is-transforming .char-image-wrapper::after {
        animation: transform-pulse 1.5s ease-in-out forwards;
        background: radial-gradient(
          circle,
          transparent 40%,
          var(--glow-cyan) 80%,
          transparent 100%
        );
        opacity: 0;
      }

      .card.is-transforming .transformed-img {
        opacity: 1;
        transition: opacity 0.2s 0.8s ease-in; /* Delay transition to match pulse */
      }

      .char-image-wrapper .transformed-img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 9999px;
        opacity: 0;
      }

      @keyframes transform-flicker {
        0%,
        100% {
          filter: brightness(1);
          transform: scale(1);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          filter: brightness(2.5) saturate(2);
          transform: scale(1.05) translateX(3px);
        }
        20%,
        40%,
        60%,
        80% {
          filter: brightness(0.8);
          transform: scale(1.05) translateX(-3px);
        }
      }

      @keyframes transform-static {
        0%,
        100% {
          opacity: 0;
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          opacity: 1;
          top: -5px;
        }
        20%,
        40%,
        60%,
        80% {
          opacity: 0.8;
          top: 5px;
        }
      }

      @keyframes transform-pulse {
        0% {
          opacity: 0;
          transform: scale(0.5);
        }
        50% {
          opacity: 0.7;
        }
        70% {
          opacity: 1;
          transform: scale(1.5);
        }
        100% {
          opacity: 0;
          transform: scale(2);
        }
      }
    </style>
  </head>
  <body class="bg-bg-dark text-gray-200">
    <canvas id="starfield-bg"></canvas>

    <div id="mode-selection-screen" class="screen-container">
      <div
        id="mode-selection-content"
        class="text-center transition-transform duration-500 ease-out"
      >
        <h1
          class="font-orbitron text-4xl md:text-6xl font-black text-white text-glow mb-2 text-center"
        >
          The Sukies
        </h1>
        <p class="text-cyan-300 md:text-lg mb-10 tracking-widest text-center">
          A Friend from Hell Story
        </p>
        <div
          class="flex flex-col md:flex-row gap-6 md:gap-8 w-full max-w-sm md:max-w-3xl"
        >
          <button
            class="mode-button glass-ui rounded-2xl p-6 sm:p-8 text-center cursor-pointer transition-all duration-300 hover:!border-cyan-400 hover:scale-105"
            data-mode="FFA"
          >
            <h2
              class="font-orbitron text-xl sm:text-3xl font-bold text-cyan-300 text-glow mb-2"
            >
              Free-for-All
            </h2>
            <p class="text-gray-300 text-sm sm:text-base">
              ทุกคนคือศัตรู เหลือรอดเป็นคนสุดท้าย
            </p>
          </button>
          <button
            class="mode-button glass-ui rounded-2xl p-6 sm:p-8 text-center cursor-pointer transition-all duration-300 hover:!border-pink-400 hover:scale-105"
            data-mode="2v2"
          >
            <h2
              class="font-orbitron text-xl sm:text-3xl font-bold text-pink-400 text-glow-pink mb-2"
            >
              2 vs 2
            </h2>
            <p class="text-gray-300 text-sm sm:text-base">
              ร่วมทีมกับ AI สู้กับทีมฝั่งตรงข้าม
            </p>
          </button>
        </div>
        <button id="how-to-play-button" class="btn-game mt-12 mx-auto">
          วิธีเล่น
        </button>
      </div>
    </div>

    <div
      id="character-selection-screen"
      class="screen-container hidden z-40 p-2 sm:p-4"
    >
      <h1
        class="font-orbitron text-3xl md:text-5xl font-bold text-white text-glow text-center mb-4 flex-shrink-0"
      >
        เลือกนักสู้
      </h1>
      <div
        class="flex flex-col w-full max-w-7xl mx-auto flex-grow min-h-0 lg:flex-row lg:gap-4 overflow-y-auto"
      >
        <div
          id="selection-grid"
          class="grid grid-cols-2 sm:grid-cols-3 gap-3 sm:gap-4 pr-2 lg:w-7/12"
          style="perspective: 1000px"
        ></div>
        <div
          id="selection-preview"
          class="glass-ui rounded-2xl p-4 sm:p-6 flex-1 lg:w-5/12 flex-col mt-4 lg:mt-0 hidden lg:flex"
        ></div>
      </div>
      <div class="text-center mt-4 flex-shrink-0">
        <button
          id="start-game-button"
          class="btn-game text-lg sm:text-xl hidden"
        >
          เริ่มการต่อสู้!
        </button>
      </div>
    </div>

    <main id="game-proper" class="screen-container hidden z-20 !p-0">
      <div class="w-full h-full mx-auto flex flex-col">
        <header
          class="flex justify-center items-center text-center p-2 flex-shrink-0 relative"
        >
          <div
            id="environment-effect-display"
            class="absolute left-2 sm:left-4 top-1/2 -translate-y-1/2 glass-ui border border-purple-500/50 rounded-xl p-2 px-4 text-left hidden md:block"
          >
            <h4 class="font-orbitron text-sm text-purple-300">สนามต่อสู้:</h4>
            <p id="environment-effect-text" class="text-xs"></p>
          </div>
          <h1
            class="font-orbitron text-xl md:text-3xl font-bold text-white text-glow"
          >
            Cosmic Brawl
          </h1>
          <button
            id="item-button"
            class="btn-game absolute right-2 sm:right-4 top-1/2 -translate-y-1/2 text-sm !p-2"
          >
            ไอเทม
          </button>
        </header>

        <div
          id="game-board"
          class="flex flex-col sm:flex-row gap-2 flex-grow min-h-0 p-2"
        >
          <div
            id="card-area"
            class="flex-grow grid grid-cols-1 sm:grid-cols-2 gap-3 overflow-y-auto p-1"
            style="perspective: 1000px"
          ></div>
          <aside
            id="action-log-container"
            class="glass-ui rounded-xl p-3 w-full sm:w-64 md:w-80 lg:max-w-xs flex-shrink-0 flex flex-col h-32 sm:h-auto"
          >
            <h3
              class="font-orbitron text-base md:text-lg font-bold mb-2 pb-2 border-b border-cyan-700/50 flex-shrink-0"
            >
              Action Log
            </h3>
            <ul
              id="action-log"
              class="overflow-y-auto flex-grow flex flex-col-reverse text-xs md:text-sm space-y-2 pr-2"
            ></ul>
          </aside>
        </div>
      </div>
      <div
        id="turn-indicator"
        class="fixed top-4 left-1/2 -translate-x-1/2 glass-ui rounded-full px-4 py-2 sm:px-6 sm:py-2 text-base sm:text-lg font-orbitron shadow-lg opacity-0 transition-all duration-500 z-30"
      >
        <span id="turn-text"></span>
      </div>
    </main>

    <div
      id="item-modal"
      class="modal-bg fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm hidden"
    >
      <div
        class="glass-ui rounded-2xl p-5 sm:p-8 max-w-2xl w-full text-left shadow-2xl shadow-yellow-500/40 border-2 border-yellow-500 modal-animate max-h-[90vh] flex flex-col"
      >
        <h2
          class="font-orbitron text-2xl sm:text-3xl font-bold mb-6 text-glow text-center flex-shrink-0"
        >
          คลังไอเทม
        </h2>
        <div
          id="item-grid"
          class="grid grid-cols-2 sm:grid-cols-4 gap-4 overflow-y-auto pr-4 flex-grow"
        ></div>
        <button id="close-item-modal-button" class="btn-game mt-8 mx-auto">
          ปิด
        </button>
      </div>
    </div>
    <div
      id="how-to-play-modal"
      class="modal-bg fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm hidden"
    >
      <div
        class="glass-ui rounded-2xl p-5 sm:p-8 max-w-2xl w-full text-left shadow-2xl shadow-cyan-500/40 border-2 border-cyan-500 modal-animate max-h-[90vh] flex flex-col"
      >
        <h2
          class="font-orbitron text-2xl sm:text-3xl font-bold mb-6 text-glow text-center flex-shrink-0"
        >
          วิธีเล่น
        </h2>
        <div class="overflow-y-auto pr-4 space-y-4 text-gray-300 flex-grow">
          <div>
            <h3 class="font-orbitron text-lg text-cyan-300 mb-2">เป้าหมาย</h3>
            <p>
              เอาชนะคู่ต่อสู้ทั้งหมดเพื่อเป็นผู้รอดชีวิตคนสุดท้าย! ในโหมด 2v2
              ต้องกำจัดทีมตรงข้ามให้หมด
            </p>
          </div>
          <div>
            <h3 class="font-orbitron text-lg text-cyan-300 mb-2">
              ค่าพลังหลัก
            </h3>
            <ul class="list-disc list-inside space-y-1">
              <li>
                <strong class="text-green-400">HP:</strong> พลังชีวิต เมื่อเหลือ
                0 จะแพ้
              </li>
              <li>
                <strong class="text-blue-400">Energy:</strong>
                ใช้สำหรับออกสกิลต่างๆ จะฟื้นฟูเมื่อจบเทิร์น
              </li>
              <li>
                <strong class="text-yellow-400">Ultimate Gauge:</strong>
                เกรจท่าไม้ตาย จะเพิ่มขึ้นเมื่อทำการต่อสู้ เมื่อเต็ม 100%
                จะใช้ท่าไม้ตายได้
              </li>
            </ul>
          </div>
          <div>
            <h3 class="font-orbitron text-lg text-cyan-300 mb-2">ไอเทม</h3>
            <p>
              คุณสามารถใช้ไอเทมได้เทิร์นละ 1 ครั้ง โดยการกดปุ่ม "ไอเทม"
              ระหว่างเทิร์นของคุณ
            </p>
          </div>
          <div>
            <h3 class="font-orbitron text-lg text-cyan-300 mb-2">
              สถานะผิดปกติ (ตัวอย่าง)
            </h3>
            <ul class="list-disc list-inside space-y-1">
              <li>
                <strong class="text-pink-400">Stun (มึนงง):</strong> ข้ามเทิร์น,
                ทำอะไรไม่ได้
              </li>
              <li>
                <strong class="text-red-400">Bleed (เลือดออก):</strong>
                เสียเลือดเมื่อจบเทิร์น
              </li>
              <li>
                <strong class="text-gray-400">Silenced (เงียบ):</strong>
                ใช้ได้แต่การโจมตีปกติ
              </li>
            </ul>
          </div>
        </div>
        <button id="close-how-to-play-button" class="btn-game mt-8 mx-auto">
          เข้าใจแล้ว!
        </button>
      </div>
    </div>
    <div
      id="skill-modal"
      class="modal-bg fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm hidden"
    >
      <div
        class="glass-ui rounded-2xl max-w-md w-full text-center shadow-2xl shadow-fuchsia-500/40 border-2 border-fuchsia-500 overflow-hidden modal-animate"
      >
        <img
          id="skill-modal-img"
          src=""
          alt="Character Skill"
          class="w-full h-56 sm:h-64 object-cover"
          onerror="this.onerror=null;this.src='https://placehold.co/400x256/010410/FFFFFF?text=Image+Error'"
        />
        <div class="p-4 sm:p-6">
          <h2
            id="skill-modal-char-name"
            class="font-orbitron text-xl sm:text-2xl font-bold text-white text-glow-pink mb-2"
          ></h2>
          <p
            id="skill-modal-quote"
            class="text-lg sm:text-xl text-gray-200"
          ></p>
        </div>
      </div>
    </div>
    <div
      id="target-modal"
      class="modal-bg fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm hidden"
    >
      <div
        class="glass-ui rounded-2xl p-4 sm:p-6 max-w-2xl w-full text-center shadow-2xl shadow-cyan-500/40 border-2 border-cyan-500 modal-animate max-h-[90vh] flex flex-col"
      >
        <h3
          class="font-orbitron text-2xl font-bold mb-6 text-glow flex-shrink-0"
        >
          เลือกเป้าหมาย
        </h3>
        <div
          id="target-options"
          class="grid grid-cols-1 md:grid-cols-2 gap-4 overflow-y-auto flex-grow"
        ></div>
        <button
          id="cancel-target-selection"
          class="btn-game mt-6 sm:mt-8 mx-auto"
        >
          ยกเลิก
        </button>
      </div>
    </div>
    <div
      id="game-over-modal"
      class="modal-bg fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm hidden"
    >
      <div
        class="glass-ui rounded-2xl p-6 sm:p-8 max-w-lg w-full text-center shadow-2xl shadow-amber-400/40 border-2 border-amber-400 modal-animate"
      >
        <h2
          id="game-over-title"
          class="font-orbitron text-3xl sm:text-4xl font-bold mb-4"
        ></h2>
        <p id="game-over-message" class="text-lg mb-8"></p>
        <button id="restart-game-button" class="btn-game text-xl">
          เล่นอีกครั้ง
        </button>
      </div>
    </div>
    <div
      id="loading-screen"
      class="fixed inset-0 z-[200] flex flex-col items-center justify-center bg-black/90 transition-opacity duration-500"
    >
      <div class="loader"></div>
      <p id="loading-text" class="text-lg text-cyan-200 mt-4">
        กำลังวาร์ปสู่สนามประลอง...
      </p>
    </div>
    <div
      id="ultimate-overlay"
      class="fixed inset-0 z-[250] pointer-events-none opacity-0"
    ></div>
    <script type="module">
      document.addEventListener("DOMContentLoaded", async () => {
        // --- UI Effects & Interactions ---
        const canvas = document.getElementById("starfield-bg");
        if (canvas) {
          const ctx = canvas.getContext("2d");
          function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          }
          const stars = [];
          const numStars = window.innerWidth < 768 ? 100 : 200;
          class Star {
            constructor() {
              this.x = Math.random() * canvas.width;
              this.y = Math.random() * canvas.height;
              this.size = Math.random() * 2 + 0.5;
              this.speed = Math.random() * 0.5 + 0.1;
            }
            draw() {
              ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
              ctx.fill();
            }
            update() {
              this.y += this.speed;
              if (this.y > canvas.height) {
                this.y = 0;
                this.x = Math.random() * canvas.width;
              }
            }
          }
          function initStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) stars.push(new Star());
          }
          function animateStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            stars.forEach((star) => {
              star.update();
              star.draw();
            });
            requestAnimationFrame(animateStars);
          }
          setCanvasSize();
          initStars();
          animateStars();
          let resizeTimer;
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              setCanvasSize();
              initStars();
            }, 250);
          });
        }

        const modeSelectionContent = document.getElementById(
          "mode-selection-content"
        );
        if (modeSelectionContent) {
          document
            .getElementById("mode-selection-screen")
            .addEventListener("mousemove", (e) => {
              const { clientX, clientY } = e;
              const { innerWidth, innerHeight } = window;
              const x = (clientX - innerWidth / 2) / (innerWidth / 2);
              const y = (clientY - innerHeight / 2) / (innerHeight / 2);
              modeSelectionContent.style.transform = `translateX(${
                -x * 10
              }px) translateY(${-y * 10}px)`;
            });
        }

        const sfx = {
          isReady: false,
          click: new Tone.PolySynth(Tone.Synth, {
            volume: -10,
            oscillator: { type: "triangle" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 },
          }).toDestination(),
          damage: new Tone.PolySynth(Tone.NoiseSynth, {
            volume: -12,
            noise: { type: "pink" },
            envelope: { attack: 0.005, decay: 0.15, sustain: 0 },
          }).toDestination(),
          heal: new Tone.PolySynth(Tone.Synth, {
            volume: -8,
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 },
          }).toDestination(),
          ultimate: new Tone.PolySynth(Tone.MembraneSynth, {
            volume: -5,
            pitchDecay: 0.05,
            octaves: 10,
            oscillator: { type: "sine" },
            envelope: {
              attack: 0.001,
              decay: 0.4,
              sustain: 0.01,
              release: 1.4,
              attackCurve: "exponential",
            },
          }).toDestination(),
          // --- เพิ่มเสียงใหม่ตรงนี้ ---
          ultimateChargeUp: new Tone.NoiseSynth({
            volume: -15,
            noise: { type: "white" },
            envelope: { attack: 0.1, decay: 0.5, sustain: 0 },
          }).toDestination(),
          item: new Tone.PolySynth(Tone.Synth, {
            volume: -8,
            oscillator: { type: "square" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 },
          }).toDestination(),
          win: new Tone.PolySynth(Tone.Synth, { volume: -8 }).toDestination(),
          lose: new Tone.PolySynth(Tone.Synth, { volume: -8 }).toDestination(),

          play(sound) {
            if (!this.isReady) return;
            try {
              switch (sound) {
                case "click":
                  this.click.triggerAttackRelease("C5", "8n");
                  break;
                case "damage":
                  this.damage.triggerAttackRelease("8n");
                  break;
                case "heal":
                  this.heal.triggerAttackRelease("A5", "8n");
                  break;
                case "item":
                  this.item.triggerAttackRelease("G4", "8n");
                  break; // --- แก้ไข case "ultimate" ตรงนี้ ---
                case "ultimate":
                  this.ultimateChargeUp.triggerAttackRelease(
                    "0.5n",
                    Tone.now()
                  );
                  this.ultimate.triggerAttackRelease(
                    "C2",
                    "8n",
                    Tone.now() + 0.2
                  );
                  break;
                case "win":
                  this.win.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                  break;
                case "lose":
                  this.lose.triggerAttackRelease(["C4", "A3", "F3"], "4n");
                  break;
              }
            } catch (e) {
              console.error("Sound playback error:", e);
            }
          },

          start() {
            document.body.addEventListener(
              "click",
              async () => {
                if (this.isReady || Tone.context.state === "running") return;
                await Tone.start();
                this.isReady = true;
                console.log("Audio context started.");
              },
              { once: true }
            );
          },
        };
        sfx.start();

        const characterData = [
          {
            id: "title",
            name: "ไตเติ้ล",
            hp: 100,
            energy: 50,
            img: "./img/title.jpg",
            transformed: false,
            transformedImg: "./img/title_transformed.jpg", // เพิ่ม property รูปแปลงร่าง
            originalSkills: [],
            passive: {
              name: "สันดานนักขุด",
              description:
                "การโจมตีปกติมีโอกาส 15% ที่จะขุดเจอ 'ความจริง' ทำให้ศัตรูเจ็บจี๊ดจน 'เลือดออก' 1 เทิร์น",
              trigger: "onAttack",
              chance: 0.15,
              effect: { type: "applyStatus", statusType: "bleed", duration: 1 },
              condition: "isBasicAttack",
            },
            skills: [
              {
                name: "เติ้ลรู้ทุกอย่าง",
                cost: 30,
                cooldown: 4,
                target: "single",
                quote: "กูเห็นนะ... ที่มึงโพสต์ไว้!",
                logMessage:
                  '"{caster_name}" ใช้ "ประจานให้อาย"! "{target_name}" อับอายจนเสียการทรงตัว!',
                effects: [
                  { type: "damage", value: 10 },
                  { type: "applyStatus", statusType: "stun", duration: 1 },
                  {
                    type: "applyStatus",
                    statusType: "defenseDown",
                    duration: 2,
                  },
                ],
              },
              {
                name: "หลักฐานในมือกูแต่มันมีเยอะกว่า",
                cost: 20,
                cooldown: 2,
                target: "self",
                quote: "มึงจะเถียงเหรอ? กูมีครบ!",
                logMessage:
                  '"{caster_name}" ใช้ "หลักฐานในมือกูแต่มันมีเยอะกว่า"! เตรียมพร้อมโต้กลับอย่างเหนือกว่า!',
                effects: [
                  { type: "heal", value: 25 },
                  { type: "applyStatus", statusType: "evade", duration: 2 },
                ],
              },
            ],
            transformedSkills: [
              {
                name: "ขุดให้ลึก",
                cost: 25,
                cooldown: 1,
                target: "single",
                quote: "เจออีกแล้ว... ความลับของมึง!",
                logMessage:
                  '"{caster_name}" ขุดคุ้ย "{target_name}" จนเจอจุดอ่อน!',
                effects: [
                  { type: "damage", value: 50 }, // เพิ่มความเสียหาย
                  { type: "applyStatus", statusType: "bleed", duration: 3 }, // เพิ่มระยะเวลาเลือดออก
                  {
                    type: "applyStatus",
                    statusType: "defenseDown",
                    duration: 1,
                    chance: 0.3,
                  }, // เพิ่มโอกาสติดป้องกันลดลง
                ],
              },
              {
                name: "ร่างทรงนักสืบ",
                cost: 35,
                cooldown: 2, // ลดคูลดาวน์
                target: "self",
                quote: "ตอนนี้... ไม่มีอะไรที่กูไม่รู้!",
                logMessage:
                  '"{caster_name}" เข้าสู่ร่างทรงนักสืบ! เพิ่มพลังโจมตีและหลบหลีก!',
                effects: [
                  { type: "applyStatus", statusType: "attackUp", duration: 3 }, // เพิ่มระยะเวลาพลังโจมตีขึ้น
                  { type: "applyStatus", statusType: "evade", duration: 2 }, // เพิ่มจำนวนครั้งหลบหลีก
                ],
              },
            ],
            ultimate: {
              name: "เติ้ลรู้ทุกคนรู้",
              cost: 100,
              target: "single",
              quote: "เสียงคุ้นๆนะมึง... ว่ามะ?",
              logMessage:
                '"{caster_name}" "เติ้ลรู้ทุกคนรู้" เกี่ยวกับ "{target_name}"! สกิลติดตัวถูกปิดผนึกด้วยความอับอาย!',
              effects: [
                { type: "damage", value: 30 },
                { type: "applyStatus", statusType: "passiveSeal", duration: 2 },
                { type: "extraDamageOnBleed", value: 30, isUltimate: true },
                { type: "transform" },
              ],
            },
          },
          {
            id: "puthai",
            name: "พูไทย",
            hp: 110,
            energy: 40,
            lives: 2, // <-- เพิ่ม property ชีวิต
            img: "./img/puthai.jpg",
            passive: {
              name: "ชีวิตที่ 2",
              description:
                "เมื่อ HP เหลือ 0 เป็นครั้งแรก จะไม่ตาย แต่จะฟื้นฟู HP จนเต็มและเข้าสู่ชีวิตที่ 2",
              trigger: "onDeath", // This is a conceptual trigger
            },
            skills: [
              {
                name: "ของดีต้องแบ่งปัน",
                cost: 30,
                cooldown: 3,
                target: "single",
                quote: "ของมึงก็เหมือนของกูแหละ...",
                logMessage:
                  '"{caster_name}" ใช้ "ของดีต้องแบ่งปัน"! ดูดพลังชีวิตจาก "{target_name}"!',
                effects: [{ type: "hpStealPercentage", value: 0.2 }],
              },
              {
                name: "ทุ่มสุดตัว",
                cost: 25,
                cooldown: 2,
                target: "self",
                quote: "เจ็บหน่อยนะ... แต่มึงรอด",
                logMessage:
                  '"{caster_name}" "ทุ่มสุดตัว" เพื่อเพิ่มพลังป้องกัน... แต่ก็เจ็บตัวเอง!",',
                effects: [
                  { type: "applyStatus", statusType: "defenseUp", duration: 1 },
                  { type: "applyStatus", statusType: "evade", duration: 1 },
                  {
                    type: "damage",
                    value: 15,
                    recipient: "caster",
                    bypassCritAndEvade: true,
                  },
                ],
              },
            ],
            ultimate: {
              name: "เกิดใหม่",
              cost: 100,
              target: "single",
              quote: "ตายแล้วเกิดใหม่... มันเป็นอย่างนี้นี่เอง",
              logMessage:
                '"{caster_name}" ใช้ "เกิดใหม่"! โจมตี "{target_name}" อย่างรุนแรงและฟื้นคืนชีพ!",',
              effects: [
                { type: "damage", value: 70 },
                { type: "heal", value: 9999, recipient: "caster" },
              ],
            },
          },
          {
            id: "aek",
            name: "พี่เอก",
            hp: 90,
            energy: 60,
            img: "./img/aek.jpg",
            passive: {
              name: "แดกไม่เลือก",
              description:
                "ทุกครั้งที่สร้างความเสียหาย จะฟื้นฟู HP 20% ของความเสียหายที่ทำได้ เหมือนกินไม่รู้จักอิ่ม",
              trigger: "onDealDamage",
              effect: { type: "lifesteal", ratio: 0.2 },
            },
            skills: [
              {
                name: "พี่ทำเอง",
                cost: 20,
                cooldown: 1,
                target: "single",
                quote: "ของมึงก็เหมือนของกูแหละ",
                logMessage:
                  '"{caster_name}" ใช้ "พี่ทำเอง"! ดูดพลังชีวิต "{target_name}" มาเป็นของตัวเอง!',
                effects: [
                  { type: "damage", value: 15 },
                  { type: "heal", value: 15, recipient: "caster" },
                ],
              },
              {
                name: "เด๋วมาฟาร์มก่อน",
                cost: 40,
                cooldown: 4,
                target: "all_enemies",
                quote: "พวกมึงทำไปก่อนเลย เดี๋ยวตาม",
                logMessage:
                  '"{caster_name}" ใช้ "เด๋วมาฟาร์มก่อน"! ทุกคนปวดหัวกับความไร้ความรับผิดชอบ!',
                effects: [{ type: "damage", value: 20 }],
              },
            ],
            ultimate: {
              name: "พี่เอกจัดให้",
              cost: 100,
              target: "single",
              quote: "เกลี้ยง! ไม่เหลือให้ใคร!",
              logMessage:
                '"{caster_name}" จัด "พี่เอกจัดให้" ใส่ "{target_name}" และฟื้นฟูตัวเองจนพุงกาง!',
              effects: [{ type: "lifesteal_damage", value: 65 }],
            },
          },
          {
            id: "touch",
            name: "ทัช",
            hp: 110,
            energy: 50,
            img: "./img/touch.jpg",
            passive: {
              name: "ทวงยันชาติหน้า",
              description:
                "เมื่อโจมตีเป้าหมายที่เป็นหนี้ (ติดสถานะเลือดออก) จะสร้างความเสียหายเพิ่มเติม 10 หน่วย",
              trigger: "onDealDamage",
              effect: { type: "extraDamageOnBleed", value: 10 },
            },
            skills: [
              {
                name: "แปปรถกูเสีย",
                cost: 25,
                cooldown: 2,
                target: "single",
                quote: "มึง! คืนเงินกู!",
                logMessage:
                  '"{caster_name}" ใช้ "แปปรถกูเสีย"! "{target_name}" กดดันจนเลือดไหลไม่หยุด!',
                effects: [
                  { type: "applyStatus", statusType: "bleed", duration: 3 },
                ],
              },
              {
                name: "valoมา",
                cost: 25,
                cooldown: 1,
                target: "single",
                quote: "พ่อมึงตายตอนจบว่ะ... โทษที",
                logMessage:
                  '"{caster_name}" ตะโกน "valoมา"! "{target_name}" เสียสมาธิอย่างรุนแรง!',
                effects: [{ type: "damage", value: 25 }],
              },
            ],
            ultimate: {
              name: "อย่างงี้รอดยาก",
              cost: 100,
              target: "all_enemies",
              quote: "หนี้เลือดต้องชำระด้วยเลือด!",
              logMessage: '"{caster_name}" ส่ง "อย่างงี้รอดยาก" ให้ศัตรูทุกคน!',
              effects: [
                { type: "damage", value: 25 },
                {
                  type: "applyStatus",
                  statusType: "stun",
                  duration: 1,
                  chance: 0.5,
                },
              ],
            },
          },
          {
            id: "geetar",
            name: "กีต้าร์",
            hp: 100,
            energy: 50,
            img: "./img/geetar.jpg",
            passive: {
              name: "จังหวะนรก",
              description:
                "เมื่อใช้สกิลบัฟตัวเอง, จะฮีลเพื่อนร่วมทีมที่เลือดน้อยสุด 15 หน่วย (เผื่อได้หน้า)",
              trigger: "onSelfSkill",
              effect: { type: "healLowestAlly", value: 15 },
            },
            skills: [
              {
                name: "ของกูไอพูไทย",
                cost: 20,
                cooldown: 4,
                target: "single",
                quote: "จะเอาไปเพื่อออ",
                logMessage:
                  '"{caster_name}" "ของกูไอพูไทย" ใส่ "{target_name}" แล้วชิ่งหนีไปอย่างรวดเร็ว!',
                effects: [
                  {
                    type: "applyStatus",
                    statusType: "stun",
                    duration: 1,
                    recipient: "target",
                  },
                  {
                    type: "applyStatus",
                    statusType: "evade",
                    duration: 2,
                    recipient: "caster",
                  },
                ],
              },
              {
                name: "กูทำเควสก่อน",
                cost: 30,
                cooldown: 3,
                target: "single",
                quote: "ขอบใจสำหรับไอเดียนะ... 'เพื่อน'",
                logMessage:
                  '"{caster_name}" ใช้ "กูทำเควสก่อน" ขโมยบัฟทั้งหมดจาก "{target_name}"!',
                effects: [{ type: "stealBuffs" }],
              },
            ],
            ultimate: {
              name: "กูไม่รู้",
              cost: 100,
              target: "single",
              quote: "โทษนะเพื่อน... แต่กูต้องรอด!",
              logMessage:
                '"{caster_name}" ใช้ "กูไม่รู้" กับ "{target_name}" แล้วสลับพลังชีวิตกันอย่างหน้าตาเฉย!',
              effects: [{ type: "swapHpPercentage" }],
            },
          },
          {
            id: "pan",
            name: "ปัณ",
            hp: 130,
            energy: 40,
            img: "./img/pan.jpg",
            passive: {
              name: "มองทะลุไส้",
              description:
                "เมื่อเริ่มเทิร์น, มีโอกาส 25% ที่จะอ่านใจศัตรูที่ HP สูงสุดได้ ทำให้ติดสถานะ 'ยั่วยุ' 1 เทิร์น",
              trigger: "onTurnStart",
              chance: 0.25,
              effect: { type: "tauntHighestHpEnemy", duration: 1 },
            },
            skills: [
              {
                name: "อย่าาาาา!!",
                cost: 30,
                cooldown: 2,
                target: "single",
                quote: "แผนอย่างนี้... เอาไว้หลอกเด็กเถอะ",
                logMessage:
                  '"{caster_name}" "อย่าาาาา!!" ทำให้แผนของ "{target_name}" พังไม่เป็นท่า!',
                effects: [
                  {
                    type: "applyStatus",
                    statusType: "passiveSeal",
                    duration: 2,
                  },
                  {
                    type: "applyStatus",
                    statusType: "defenseDown",
                    duration: 2,
                  },
                ],
              },
              {
                name: "มันเป็นแผนของกู",
                cost: 20,
                cooldown: 2,
                target: "self",
                quote: "มาดิ! เข้ามาเลย!",
                logMessage:
                  '"{caster_name}" "มันเป็นแผนของกู" พร้อมยั่วยุศัตรูทั้งหมด!',
                effects: [
                  { type: "applyStatus", statusType: "defenseUp", duration: 1 },
                  { type: "applyStatus", statusType: "taunt", duration: 1 },
                ],
              },
            ],
            ultimate: {
              name: "กูคือบอส",
              cost: 100,
              target: "all_allies",
              quote: "ทุกอย่าง... เป็นไปตามที่กูคิดไว้เป๊ะ",
              logMessage:
                '"{caster_name}" "กูคือบอส"! สร้างโล่ป้องกันให้เพื่อนร่วมทีมทุกคนตามแผนที่วางไว้!',
              effects: [{ type: "applyShield", value: 50 }],
            },
          },
        ];

        const GAME_CONSTANTS = {
          CRIT_CHANCE: 0.1,
          CRIT_MULTIPLIER: 1.5,
          DEFENSE_UP_MULTIPLIER: 0.5,
          DEFENSE_DOWN_MULTIPLIER: 1.5,
          ULTIMATE_CHARGE_PER_ACTION: 25,
          MAX_ULTIMATE_CHARGE: 100,
          TURN_END_ENERGY_REGEN: 10,
          BLEED_DAMAGE: 10,
          BUFF_TYPES: ["defenseUp", "evade", "shield"],
        };
        const STATUS_DESCRIPTIONS = {
          stun: "มึนงง: ไม่สามารถกระทำการใดๆ ได้ในเทิร์นถัดไป",
          bleed: "เลือดออก: ได้รับความเสียหายเมื่อจบเทิร์น",
          evade: "หลบหลีก: จะหลบการโจมตีครั้งถัดไปได้สำเร็จ 100%",
          silenced: "เงียบ: ไม่สามารถใช้สกิลได้",
          defenseUp: "เพิ่มพลังป้องกัน",
          defenseDown: "ลดพลังป้องกัน",
          taunt: "ยั่วยุ",
          passiveSeal: "ผนึกสกิลติดตัว",
          attackUp: "เพิ่มพลังโจมตี",
          shield: "โล่ป้องกัน",
        };
        const ENVIRONMENTS = [
          {
            id: "magnetic_field",
            name: "สนามแม่เหล็ก",
            description: "เมื่อจบเทิร์น ทุกคนเสีย 5 Energy",
          },
          {
            id: "sacred_ground",
            name: "พื้นที่ศักดิ์สิทธิ์",
            description: "การฟื้นฟู HP ทั้งหมดมีผลเพิ่มขึ้น 25%",
          },
          {
            id: "whirlwind",
            name: "พายุหมุน",
            description:
              "เมื่อเริ่มรอบใหม่ มีโอกาส 15% ที่ตัวละคร 2 ตัวจะสลับตำแหน่งกัน",
          },
        ];

        let gameState = {
          characters: [],
          currentPlayerIndex: 0,
          isActionInProgress: false,
          gameMode: "FFA",
          actionQueue: [],
          isPlayerTurn: true,
          currentEnvironment: null,
          selectedPlayerId: null,
          itemUsedThisTurn: false,
          playerData: {
            inventory: { potion: 3, bomb: 2 }, // Default items
          },
        };

        const DOM = {
          modeSelectionScreen: document.getElementById("mode-selection-screen"),
          characterSelectionScreen: document.getElementById(
            "character-selection-screen"
          ),
          selectionGrid: document.getElementById("selection-grid"),
          selectionPreview: document.getElementById("selection-preview"),
          startGameButton: document.getElementById("start-game-button"),
          gameProper: document.getElementById("game-proper"),
          cardArea: document.getElementById("card-area"),
          actionLog: document.getElementById("action-log"),
          allModals: document.querySelectorAll(".modal-bg"),
          skillModal: document.getElementById("skill-modal"),
          targetModal: document.getElementById("target-modal"),
          gameOverModal: document.getElementById("game-over-modal"),
          loadingScreen: document.getElementById("loading-screen"),
          turnIndicator: document.getElementById("turn-indicator"),
          restartGameButton: document.getElementById("restart-game-button"),
          cancelTargetSelectionButton: document.getElementById(
            "cancel-target-selection"
          ),
          howToPlayModal: document.getElementById("how-to-play-modal"),
          howToPlayButton: document.getElementById("how-to-play-button"),
          closeHowToPlayButton: document.getElementById(
            "close-how-to-play-button"
          ),
          itemButton: document.getElementById("item-button"),
          itemModal: document.getElementById("item-modal"),
          itemGrid: document.getElementById("item-grid"),
          closeItemModalButton: document.getElementById(
            "close-item-modal-button"
          ),
        };

        // All function definitions
        function setupTutorialModal() {
          DOM.howToPlayButton.addEventListener("click", () => {
            sfx.play("click");
            DOM.howToPlayModal.classList.remove("hidden");
          });
          DOM.closeHowToPlayButton.addEventListener("click", () => {
            sfx.play("click");
            DOM.howToPlayModal.classList.add("hidden");
          });
        }
        function setupModeSelection() {
          DOM.modeSelectionScreen.classList.remove("hidden");
          DOM.characterSelectionScreen.classList.add("hidden");
          DOM.gameProper.classList.add("hidden");
          document.querySelectorAll(".mode-button").forEach((button) => {
            button.onclick = () => {
              sfx.play("click");
              gameState.gameMode = button.dataset.mode;
              DOM.modeSelectionScreen.classList.add("hidden");
              setTimeout(
                () => DOM.characterSelectionScreen.classList.remove("hidden"),
                50
              );
              showCharacterSelection();
            };
          });
        }
        function selectCharacter(selectedId) {
          sfx.play("click");
          gameState.selectedPlayerId = selectedId;
          const char = characterData.find((c) => c.id === selectedId);
          updateSelectionPreview(char);
          DOM.startGameButton.classList.remove("hidden");
        }

        // --- MODIFIED FUNCTION ---
        function showCharacterSelection() {
          DOM.selectionGrid.innerHTML = "";
          gameState.selectedPlayerId = null;
          DOM.startGameButton.classList.add("hidden");
          updateSelectionPreview(null);
          characterData.forEach((char) => {
            const portrait = document.createElement("div");
            portrait.className =
              "card selection-portrait glass-ui rounded-lg p-2 sm:p-3 cursor-pointer transition-transform duration-300 ease-out border-2 border-transparent hover:!border-cyan-400";
            portrait.dataset.charId = char.id;
            portrait.innerHTML = `
                        <img src="${char.img}" alt="${char.name}" class="w-full h-24 sm:h-32 object-cover rounded-md mb-2 transition-all duration-300 ease-in-out">
                        <div class="font-orbitron text-center text-white text-base sm:text-lg">${char.name}</div>
                    `;
            portrait.addEventListener("click", () => selectCharacter(char.id));
            DOM.selectionGrid.appendChild(portrait);
          });
          add3dHoverEffect("#selection-grid");
        }

        async function executeSkill(caster, targets, skill) {
          const skillIndex = caster.skills.findIndex(
            (s) => s && s.name === skill.name
          );
          if (skillIndex > -1) {
            if (skill.isUltimate) {
              sfx.play("ultimate");
              caster.ultimateCharge = 0;
              // Special logic for Puthai's ultimate
              if (
                skill.name === "เกิดใหม่" &&
                caster.id === "puthai" &&
                caster.lives > 1
              ) {
                caster.lives--;
                logAction(
                  `🔥 ${caster.name} สละชีวิต 1 ดวงเพื่อใช้พลังสูงสุด!`,
                  "log-ultimate"
                );
              }
            } else {
              caster.energy -= skill.cost;
            }
            if (skill.cooldown > 0)
              caster.skillCooldowns[skillIndex] = skill.cooldown;
          }
          if (skill.target === "self" || skill.target === "all_allies") {
            triggerPassive(caster, "onSelfSkill");
          }
          await showSkillActivationModal(caster, skill);
          const message = skill.logMessage
            .replace("{caster_name}", caster.name)
            .replace("{target_name}", targets[0] ? targets[0].name : "");
          logAction(
            `${skill.isUltimate ? "🌟" : "💫"} ${message}`,
            skill.isUltimate ? "log-ultimate" : "log-status"
          );
          for (const target of targets) {
            if (target.hp <= 0) continue;
            let totalDamageDealt = 0;
            if (skill.effects) {
              for (const effect of skill.effects) {
                // Pass caster for recoil damage case
                const damageDealt = await applyEffect(
                  caster,
                  target,
                  effect,
                  skill.isUltimate,
                  caster
                );
                if (typeof damageDealt === "number") {
                  totalDamageDealt += damageDealt;
                }
              }
            }
            if (totalDamageDealt > 0) {
              triggerPassive(caster, "onDealDamage", {
                damageDealt: totalDamageDealt,
                target: target,
              });
            }
            if (skill.isBasicAttack) {
              triggerPassive(caster, "onAttack", {
                target: target,
                isBasicAttack: true,
              });
            }
          }
          await playAttackAnimation(caster, targets);
          updateAllUI();
          if (!checkGameOver()) {
            setTimeout(endTurn, 400);
          }
          //... ภายในฟังก์ชัน executeSkill
          if (skill.isUltimate) {
            sfx.play("ultimate");

            // --- เพิ่มโค้ดเอฟเฟคตรงนี้ ---
            const gameContainer = document.getElementById("game-proper");
            const overlay = document.getElementById("ultimate-overlay");

            // ทำให้หน้าจอสั่น
            gameContainer.classList.add("screen-shake-animate");

            // แสดงแสงแฟลช
            overlay.classList.add("flash");

            // เอาเอฟเฟคออกหลังจากเวลาผ่านไป
            setTimeout(() => {
              gameContainer.classList.remove("screen-shake-animate");
              overlay.classList.remove("flash");
              overlay.style.opacity = 0; // บังคับให้หายไป
            }, 600);
            // --- จบส่วนโค้ดเอฟเฟค ---
          }
          //...
          //... ภายในฟังก์ชัน executeSkill และอยู่ใน if (skill.isUltimate)
          const cardArea = document.getElementById("card-area");
          const casterCard = document.getElementById(`card-${caster.id}`);

          // เพิ่มคลาสเพื่อเริ่มเอฟเฟค
          cardArea.classList.add("ultimate-active");
          casterCard.classList.add("ultimate-focus");
          targets.forEach((target) => {
            const targetCard = document.getElementById(`card-${target.id}`);
            if (targetCard) targetCard.classList.add("ultimate-focus");
          });

          // เอาคลาสออกเพื่อจบเอฟเฟค
          setTimeout(() => {
            cardArea.classList.remove("ultimate-active");
            casterCard.classList.remove("ultimate-focus");
            targets.forEach((target) => {
              const targetCard = document.getElementById(`card-${target.id}`);
              if (targetCard) targetCard.classList.remove("ultimate-focus");
            });
          }, 2500); // ตั้งเวลาให้ตรงกับ modal แสดง quote
          //...
        }
        function applyDamage(
          caster,
          target,
          amount,
          bypassCritAndEvade = false
        ) {
          sfx.play("damage");
          if (!bypassCritAndEvade && hasStatus(target, "evade")) {
            logAction(`💨 ${target.name} หลบการโจมตีได้!`, "log-status");
            removeStatus(target, "evade");
            return 0;
          }
          let finalDamage = amount;
          if (target.shield > 0) {
            const damageToShield = Math.min(target.shield, finalDamage);
            target.shield -= damageToShield;
            finalDamage -= damageToShield;
            logAction(
              `🛡️ โล่ของ ${target.name} ดูดซับความเสียหาย ${damageToShield} หน่วย!`,
              "log-shield"
            );
            if (target.shield <= 0) removeStatus(target, "shield", false);
          }
          if (finalDamage <= 0) {
            updateAllUI();
            return amount - finalDamage;
          }
          if (hasStatus(target, "defenseUp"))
            finalDamage *= GAME_CONSTANTS.DEFENSE_UP_MULTIPLIER;
          if (hasStatus(target, "defenseDown"))
            finalDamage *= GAME_CONSTANTS.DEFENSE_DOWN_MULTIPLIER;
          if (caster && hasStatus(caster, "attackUp")) {
            finalDamage *= 1.5;
          }
          let isCrit = false;
          if (
            !bypassCritAndEvade &&
            Math.random() < GAME_CONSTANTS.CRIT_CHANCE
          ) {
            isCrit = true;
            finalDamage = Math.round(
              finalDamage * GAME_CONSTANTS.CRIT_MULTIPLIER
            );
            logAction(`💥 คริติคอล!`, "log-crit");
          }
          finalDamage = Math.round(finalDamage);
          target.hp = Math.max(0, target.hp - finalDamage);
          showHitEffect(
            document.getElementById(`card-${target.id}`),
            `-${finalDamage}`,
            isCrit ? "crit" : "damage"
          );

          if (target.hp <= 0) {
            // Puthai's second life logic
            if (target.id === "puthai" && target.lives > 1) {
              target.lives--;
              target.hp = target.maxHp;
              sfx.play("heal");
              logAction(
                "🔥 พูไทยไม่ยอมแพ้! ชีวิตที่ 2 เริ่มต้นขึ้น!",
                "log-ultimate"
              );
              return finalDamage; // Return damage dealt before reviving
            }
            logAction(`💀 ${target.name} ถูกกำจัดแล้ว!`, "log-damage");
          }
          return finalDamage; // Return damage that went through
        }
        function heal(target, amount) {
          sfx.play("heal");
          const newHp = Math.min(target.maxHp, target.hp + amount);
          const healedAmount = newHp - target.hp;
          if (healedAmount <= 0) return;
          target.hp = newHp;
          showHitEffect(
            document.getElementById(`card-${target.id}`),
            `+${healedAmount}`,
            "heal"
          );
          logAction(`💚 ${target.name} ฟื้นฟู ${healedAmount} HP!`, "log-heal");
        }
        function add3dHoverEffect(containerSelector) {
          const container = document.querySelector(containerSelector);
          if (!container) return;
          container.addEventListener("mousemove", (e) => {
            if (!e.target.closest(".card")) return;
            const card = e.target.closest(".card");
            const { left, top, width, height } = card.getBoundingClientRect();
            const x = (e.clientX - left - width / 2) / (width / 2);
            const y = (e.clientY - top - height / 2) / (height / 2);
            card.style.transform = `rotateY(${x * 10}deg) rotateX(${
              -y * 10
            }deg) scale(1.05)`;
            card.style.zIndex = "50";
          });
          container.addEventListener("mouseout", (e) => {
            if (!e.target.closest(".card")) return;
            const card = e.target.closest(".card");
            card.style.transform = "rotateY(0) rotateX(0) scale(1)";
            card.style.zIndex = "1";
          });
        }
        function initGame(selectedPlayerId) {
          const createCharacterInstance = (charTemplate) => {
            const basicAttack = {
              name: "ตีธรรมดา",
              cost: 0,
              cooldown: 0,
              target: "single",
              isBasicAttack: true,
              quote: "เอาไปก่อน!",
              logMessage: '"{caster_name}" ตบหน้า "{target_name}"!',
              effects: [{ type: "damage", value: 10 }],
            };
            const allSkills = [
              basicAttack,
              ...(charTemplate.skills || []),
              charTemplate.ultimate,
            ].filter(Boolean);

            // --- แก้ไขตรงนี้ ---
            const character = {
              ...JSON.parse(JSON.stringify(charTemplate)), // คัดลอกข้อมูลทั้งหมดจากแม่แบบมา
              maxHp: charTemplate.hp,
              maxEnergy: charTemplate.energy,
              passive: JSON.parse(JSON.stringify(charTemplate.passive || {})),
              skills: allSkills,
              isPlayer: false,
              ultimateCharge: 0,
              shield: 0,
              statuses: [],
              skillCooldowns: Array(allSkills.length).fill(0),
              team: 0,
              lives: charTemplate.lives || 1,
            };
            // --- จบการแก้ไข ---

            const ultimateName = charTemplate.ultimate?.name;
            character.skills.forEach((s) => {
              s.isUltimate = s.name === ultimateName;
            });

            // ตรวจสอบและบันทึกสกิลดั้งเดิมของไตเติ้ล
            if (charTemplate.id === "title") {
              character.originalSkills = JSON.parse(
                JSON.stringify(character.skills)
              );
            }
            return character;
          };

          const fullCharacterPool = characterData.map(createCharacterInstance);
          const player = fullCharacterPool.find(
            (c) => c.id === selectedPlayerId
          );
          player.isPlayer = true;
          let aiPool = fullCharacterPool
            .filter((c) => c.id !== selectedPlayerId)
            .sort(() => 0.5 - Math.random());
          if (gameState.gameMode === "2v2") {
            const teamMate = aiPool.shift();
            const enemies = aiPool.slice(0, 2);
            gameState.characters = [player, teamMate, ...enemies].filter(
              Boolean
            );
            player.team = 1;
            if (teamMate) teamMate.team = 1;
            enemies.forEach((e) => (e.team = 2));
          } else {
            gameState.characters = [player, ...aiPool.slice(0, 3)];
            gameState.characters.forEach((c, i) => {
              c.team = i + 1;
            });
          }
          gameState.characters.sort(() => 0.5 - Math.random());
          gameState.currentPlayerIndex = 0;
          const firstPlayer = gameState.characters[0];
          gameState.isPlayerTurn = firstPlayer.isPlayer;
          gameState.isActionInProgress = false;
          gameState.actionQueue = [];
          DOM.cardArea.innerHTML = "";
          DOM.actionLog.innerHTML = "";
          gameState.currentEnvironment =
            ENVIRONMENTS[Math.floor(Math.random() * ENVIRONMENTS.length)];
          const envDisplay = document.getElementById(
            "environment-effect-display"
          );
          if (envDisplay) {
            document.getElementById("environment-effect-text").textContent =
              gameState.currentEnvironment.description;
            envDisplay.querySelector(
              "h4"
            ).textContent = `สนามต่อสู้: ${gameState.currentEnvironment.name}`;
          }
          logAction(
            `🪐 สนามต่อสู้: ${gameState.currentEnvironment.name}!`,
            "log-turn"
          );
          gameState.characters.forEach(createCharacterCard);
          add3dHoverEffect("#card-area");
          updateAllUI();
          logAction(
            `🔥 เริ่มการต่อสู้โหมด ${gameState.gameMode}! 🔥`,
            "log-turn"
          );
          DOM.loadingScreen.classList.add("hidden", "opacity-0");
          DOM.gameProper.classList.remove("hidden");
          showTurnIndicator(firstPlayer.name, firstPlayer.isPlayer);
          processTurnStart(firstPlayer);
        }
        // --- MODIFIED FUNCTION ---
        function updateSelectionPreview(char) {
          const preview = DOM.selectionPreview;
          if (!char) {
            preview.classList.add("hidden");
            preview.classList.remove("flex");
            return;
          }
          preview.classList.remove("hidden");
          preview.classList.add("flex");
          document
            .querySelectorAll(".selection-portrait")
            .forEach((p) => p.classList.remove("border-cyan-400", "scale-105"));
          const currentPortrait = document.querySelector(
            `.selection-portrait[data-char-id="${char.id}"]`
          );
          if (currentPortrait)
            currentPortrait.classList.add("border-cyan-400", "scale-105");

          let skillsHtml = (char.skills || [])
            .map(
              (skill) =>
                `<div class="text-sm"><strong class="text-cyan-300">${
                  skill.name
                }:</strong> <span class="text-gray-300">${generateSkillEffectDescription(
                  skill
                )}</span></div>`
            )
            .join("");
          let ultimateHtml = char.ultimate
            ? `<div class="text-sm"><strong class="text-pink-400">${
                char.ultimate.name
              } (ULT):</strong> <span class="text-gray-300">${generateSkillEffectDescription(
                char.ultimate
              )}</span></div>`
            : "";
          let passiveHtml = char.passive
            ? `<p class="text-gray-300">${char.passive.description}</p>`
            : '<p class="text-gray-500">ไม่มี</p>';

          let statsText = `HP: ${char.hp} | Energy: ${char.energy}`;
          if (char.lives && char.lives > 1) {
            statsText += ` | Lives: ${char.lives}`;
          }

          preview.innerHTML = `
                    <div class="flex flex-col h-full">
                        <div class="flex flex-col sm:flex-row items-center gap-4 mb-4 flex-shrink-0">
                            <div class="relative w-24 h-24 md:w-28 md:h-28 flex-shrink-0">
                                <div class="char-image-wrapper player">
                                    <img src="${char.img}" alt="${
            char.name
          }" onerror="this.onerror=null;this.src='https://placehold.co/128x128/0c1735/FFFFFF?text=${
            char.name
          }';">
                                </div>
                            </div>
                            <div class="text-center sm:text-left">
                                <h2 class="font-orbitron text-2xl md:text-3xl font-bold text-white text-glow">${
                                  char.name
                                }</h2>
                                <p class="text-cyan-200">${statsText}</p>
                            </div>
                        </div>
                        <div class="overflow-y-auto pr-2 flex-grow space-y-3">
                            <div><h3 class="font-orbitron text-md font-bold text-pink-400 mb-1">Passive: ${
                              char.passive ? char.passive.name : ""
                            }</h3>${passiveHtml}</div>
                            <div><h3 class="font-orbitron text-md font-bold text-cyan-300 mb-2">Skills</h3><div class="space-y-2">${skillsHtml}</div></div>
                            <div><h3 class="font-orbitron text-md font-bold text-fuchsia-400 mb-2">Ultimate</h3>${ultimateHtml}</div>
                        </div>
                    </div>`;
        }

        // --- MODIFIED FUNCTION ---
        function createCharacterCard(character) {
          const playerTeamId =
            gameState.characters.find((c) => c.isPlayer)?.team ?? -1;
          let teamClass = "card-border-glow-player";
          let wrapperTeamClass = "player";

          let isEnemy = false;
          if (gameState.gameMode === "2v2") {
            isEnemy = character.team !== playerTeamId;
          } else {
            isEnemy = !character.isPlayer;
          }

          if (isEnemy) {
            teamClass = "card-border-glow-enemy";
            wrapperTeamClass = "enemy";
          }

          const card = document.createElement("div");
          card.id = `card-${character.id}`;
          card.className = `card glass-ui rounded-2xl p-3 sm:p-4 flex flex-col transition-transform duration-300 ease-out ${teamClass} card-warp-in-animate`;
          card.innerHTML = `
                    <div class="flex items-center gap-3 mb-2 sm:mb-3">
                        <div class="relative char-image-container flex-shrink-0 w-16 h-16 sm:w-20 sm:h-20">
                            <div class="lives-indicator"></div>
                            <div class="char-image-wrapper ${wrapperTeamClass}">
                                <img src="${character.img}" alt="${
            character.name
          }" onerror="this.onerror=null;this.src='https://placehold.co/80x80/0c1735/FFFFFF?text=${character.name.slice(
            0,
            1
          )}';">
                            </div>
                            <div class="shield-display absolute inset-0 rounded-full flex items-center justify-center font-orbitron text-xl sm:text-2xl text-white pointer-events-none" style="background: rgba(0, 188, 212, 0.5); text-shadow: 0 0 5px black; display: none;"></div>
                        </div>
                        <h2 class="font-orbitron text-lg sm:text-xl font-bold text-white flex-1 truncate">${
                          character.name
                        }</h2>
                    </div>
                    <div class="w-full space-y-2 mb-2 sm:mb-3">
                        <div class="bar-container hp-bar"><div class="bar-inner"><span class="bar-text"></span></div></div>
                        <div class="bar-container energy-bar"><div class="bar-inner"><span class="bar-text"></span></div></div>
                        <div class="bar-container ultimate-bar"><div class="bar-inner"><span class="bar-text"></span></div></div>
                    </div>
                    <div class="status-effects flex flex-wrap justify-center gap-2 min-h-[36px] mb-3"></div>
                    <div class="skills w-full grid grid-cols-2 gap-2 mt-auto"></div>
                `;
          const skillsContainer = card.querySelector(".skills");
          character.skills.forEach((skill, skillIndex) => {
            if (!skill) return;
            const skillButton = document.createElement("button");
            const isUltimate = skill.isUltimate;
            skillButton.className = `btn-game skill-button p-2 text-xs sm:text-sm rounded-lg relative disabled:opacity-50 disabled:cursor-not-allowed disabled:!transform-none disabled:!shadow-none disabled:hover:!border-transparent ${
              isUltimate ? "col-span-2" : ""
            }`;
            skillButton.dataset.skillIndex = skillIndex;
            if (character.isPlayer) {
              skillButton.onclick = () =>
                onSkillClick(character.id, skillIndex);
            }
            skillsContainer.appendChild(skillButton);
          });
          DOM.cardArea.appendChild(card);
        }

        function updateAllUI() {
          gameState.characters.forEach((char) => {
            const card = document.getElementById(`card-${char.id}`);
            if (!card) return;
            if (char.hp <= 0) {
              if (!card.classList.contains("card-glitch-out-animate"))
                card.classList.add("card-glitch-out-animate");
              return;
            }
            // Update lives indicator for Puthai
            const livesIndicator = card.querySelector(".lives-indicator");
            if (char.id === "puthai") {
              livesIndicator.textContent = `x${char.lives}`;
              livesIndicator.classList.add("visible");
            } else {
              livesIndicator.classList.remove("visible");
            }

            card.querySelector(".hp-bar .bar-inner").style.width = `${
              (char.hp / char.maxHp) * 100
            }%`;
            card.querySelector(
              ".hp-bar .bar-text"
            ).textContent = `HP: ${char.hp}/${char.maxHp}`;
            card.querySelector(".energy-bar .bar-inner").style.width = `${
              (char.energy / char.maxEnergy) * 100
            }%`;
            card.querySelector(
              ".energy-bar .bar-text"
            ).textContent = `EN: ${char.energy}/${char.maxEnergy}`;
            const ultimateBar = card.querySelector(".ultimate-bar .bar-inner");
            ultimateBar.style.width = `${
              (char.ultimateCharge / GAME_CONSTANTS.MAX_ULTIMATE_CHARGE) * 100
            }%`;
            ultimateBar.querySelector(
              ".bar-text"
            ).textContent = `ULT: ${char.ultimateCharge}%`;
            ultimateBar.classList.toggle(
              "full",
              char.ultimateCharge >= GAME_CONSTANTS.MAX_ULTIMATE_CHARGE
            );
            const shieldDisplay = card.querySelector(".shield-display");
            shieldDisplay.style.display = char.shield > 0 ? "flex" : "none";
            shieldDisplay.textContent = char.shield > 0 ? char.shield : "";
            const statusContainer = card.querySelector(".status-effects");
            statusContainer.innerHTML = "";
            const statusColorMap = {
              stun: "bg-pink-600",
              bleed: "bg-red-700",
              evade: "bg-purple-600",
              silenced: "bg-gray-500",
              defenseUp: "bg-sky-500",
              defenseDown: "bg-orange-500",
              taunt: "bg-red-900",
              passiveSeal: "bg-indigo-700",
              shield: "bg-cyan-500",
            };
            char.statuses.forEach((status) => {
              statusContainer.innerHTML += ` <div title="${
                STATUS_DESCRIPTIONS[status.type] || ""
              }" class="relative w-7 h-7 sm:w-8 sm:h-8 rounded-full flex items-center justify-center text-xs font-bold border border-white/50 ${
                statusColorMap[status.type] || "bg-gray-400"
              }"> ${status.type
                .slice(0, 2)
                .toUpperCase()} <span class="absolute -bottom-1 -right-1 bg-black/80 text-amber-400 text-[10px] w-4 h-4 rounded-full flex items-center justify-center border border-white/50">${
                status.duration
              }</span> </div>`;
            });
            card.querySelectorAll(".skill-button").forEach((button) => {
              const index = parseInt(button.dataset.skillIndex, 10);
              const skill = char.skills[index];
              if (!skill) {
                button.disabled = true;
                return;
              }
              const cooldown = char.skillCooldowns[index];
              const isSilencedAndNotBasic =
                hasStatus(char, "silenced") && !skill.isBasicAttack;
              const isUltimate = skill.isUltimate;
              let isDisabled =
                !gameState.isPlayerTurn ||
                !char.isPlayer ||
                gameState.isActionInProgress ||
                cooldown > 0 ||
                hasStatus(char, "stun") ||
                char.hp <= 0;
              if (isUltimate) {
                if (char.ultimateCharge < GAME_CONSTANTS.MAX_ULTIMATE_CHARGE)
                  isDisabled = true;
              } else {
                if (char.energy < skill.cost || isSilencedAndNotBasic)
                  isDisabled = true;
              }
              button.disabled = isDisabled;
              let skillText = skill.name;
              if (isUltimate) skillText = `ULT: ${skill.name}`;
              else if (skill.cost > 0)
                skillText = `${skill.name} (${skill.cost}E)`;
              button.textContent = skillText;
              const oldCd = button.querySelector(".cooldown-text");
              if (oldCd) oldCd.remove();
              if (cooldown > 0) {
                button.insertAdjacentHTML(
                  "beforeend",
                  `<span class="cooldown-text absolute top-0 right-0 bg-amber-400 text-black text-xs font-bold w-6 h-6 rounded-full flex items-center justify-center border-2 border-white transform translate-x-1/3 -translate-y-1/3">${cooldown}</span>`
                );
              }
            });
          });
        }
        function logAction(message, type = "log-info") {
          const li = document.createElement("li");
          const colorMap = {
            "log-damage": "text-red-400",
            "log-heal": "text-green-400",
            "log-shield": "text-cyan-400",
            "log-status": "text-sky-400",
            "log-info": "text-gray-400 italic",
            "log-ultimate": "text-yellow-300 font-bold",
            "log-turn":
              "text-white font-bold text-center bg-white/10 py-1 my-1",
            "log-crit": "text-amber-400 font-bold scale-105",
          };
          li.className = `px-2 transition-opacity duration-300 ${
            colorMap[type] || "text-cyan-200"
          }`;
          li.innerHTML = message;
          DOM.actionLog.prepend(li);
          if (DOM.actionLog.children.length > 50)
            DOM.actionLog.removeChild(DOM.actionLog.lastChild);
        }
        async function onSkillClick(casterId, skillIndex) {
          sfx.play("click");
          if (gameState.isActionInProgress) return;
          const caster = findCharacter(casterId);
          if (!caster) return;
          const skill = caster.skills[skillIndex];
          gameState.actionQueue.push({ caster, skill });
          processNextAction();
        }
        async function processNextAction() {
          if (
            gameState.isActionInProgress ||
            gameState.actionQueue.length === 0
          )
            return;
          gameState.isActionInProgress = true;
          updateAllUI();
          const action = gameState.actionQueue.shift();
          const { caster, skill, preselectedTarget } = action;
          if (caster.hp <= 0) {
            gameState.isActionInProgress = false;
            processNextAction();
            return;
          }
          const getTaunter = () =>
            gameState.characters.find(
              (c) => hasStatus(c, "taunt") && c.team !== caster.team && c.hp > 0
            );
          let taunter = getTaunter();
          let targets = [];
          if (taunter && skill.target === "single" && !skill.isBasicAttack) {
            logAction(
              `⚔️ ${caster.name} ถูกยั่วยุ! ต้องโจมตี ${taunter.name}!`,
              "log-info"
            );
            targets = [taunter];
          } else if (preselectedTarget) {
            targets = [preselectedTarget];
          } else {
            targets = await determineTargets(caster, skill);
          }
          if (targets === null) {
            gameState.isActionInProgress = false;
            updateAllUI();
            return;
          }
          if (targets && targets.length > 0) {
            await executeSkill(caster, targets, skill);
          } else {
            logAction(`🤔 ไม่มีเป้าหมายสำหรับ ${skill.name}!`, "log-info");
            gameState.isActionInProgress = false;
            if (!checkGameOver()) {
              endTurn();
            }
          }
        }
        async function determineTargets(caster, skill) {
          const getEnemies = (c) =>
            gameState.characters.filter(
              (char) => char.hp > 0 && char.team !== c.team
            );
          const getAllies = (c) =>
            gameState.characters.filter(
              (char) => char.hp > 0 && char.team === c.team
            );
          const getAllOthers = (c) =>
            gameState.characters.filter(
              (char) => char.hp > 0 && char.id !== c.id
            );
          switch (skill.target) {
            case "self":
              return [caster];
            case "all_enemies":
              return gameState.gameMode === "2v2"
                ? getEnemies(caster)
                : getAllOthers(caster);
            case "all_allies":
              return getAllies(caster);
            case "single":
              const possibleTargets =
                gameState.gameMode === "2v2"
                  ? getEnemies(caster)
                  : getAllOthers(caster);
              if (possibleTargets.length === 0) return [];
              return await selectTarget(possibleTargets);
            default:
              return [];
          }
        }
        function endTurn() {
          gameState.itemUsedThisTurn = false;
          const prevChar = gameState.characters[gameState.currentPlayerIndex];
          if (prevChar && prevChar.hp > 0) {
            handleStatusEffectsAtTurnEnd(prevChar);
            triggerPassive(prevChar, "onTurnEnd");
            prevChar.ultimateCharge = Math.min(
              GAME_CONSTANTS.MAX_ULTIMATE_CHARGE,
              prevChar.ultimateCharge +
                GAME_CONSTANTS.ULTIMATE_CHARGE_PER_ACTION
            );
          }
          if (checkGameOver()) return;
          tickDownCooldowns(prevChar);
          if (
            gameState.currentPlayerIndex === gameState.characters.length - 1 &&
            gameState.currentEnvironment.id === "whirlwind" &&
            Math.random() < 0.15
          ) {
            handleWhirlwind();
          }
          let nextPlayerIndex =
            (gameState.currentPlayerIndex + 1) % gameState.characters.length;
          let loopGuard = 0;
          while (gameState.characters[nextPlayerIndex].hp <= 0) {
            if (loopGuard++ > gameState.characters.length * 2) {
              showGameOver(null);
              return;
            }
            nextPlayerIndex =
              (nextPlayerIndex + 1) % gameState.characters.length;
          }
          gameState.currentPlayerIndex = nextPlayerIndex;
          const nextPlayer = gameState.characters[gameState.currentPlayerIndex];
          gameState.isPlayerTurn = nextPlayer.isPlayer;
          gameState.isActionInProgress = false;
          showTurnIndicator(nextPlayer.name, nextPlayer.isPlayer);
          updateAllUI();
          processTurnStart(nextPlayer);
        }
        async function showGameOver(winnerOrPlayerTeamWon) {
          if (gameState.gameMode === "2v2") {
            sfx.play(winnerOrPlayerTeamWon ? "win" : "lose");
          } else {
            const winner = winnerOrPlayerTeamWon;
            if (winner && winner.isPlayer) sfx.play("win");
            else if (winner) sfx.play("lose");
            else sfx.play("lose");
          }
          DOM.gameOverModal.classList.remove("hidden");
          gameState.isActionInProgress = true;
          const title = DOM.gameOverModal.querySelector("#game-over-title");
          const message = DOM.gameOverModal.querySelector("#game-over-message");
          if (gameState.gameMode === "2v2") {
            title.textContent = winnerOrPlayerTeamWon
              ? "🎉 VICTORY 🎉"
              : "😭 DEFEAT 😭";
            message.textContent = winnerOrPlayerTeamWon
              ? "สุดยอดไปเลย!"
              : "พยายามใหม่ครั้งหน้านะ!";
          } else {
            const winner = winnerOrPlayerTeamWon;
            if (winner) {
              title.textContent = `🎉 ${winner.name} WINS!`;
              message.textContent =
                "เหลือรอดเป็นคนสุดท้ายในสนามรบแห่งมิตรภาพที่แตกสลาย!";
            } else {
              title.textContent = "😭 DRAW ?";
              message.textContent = "ไม่มีผู้ใดรอดชีวิตจากความวุ่นวายนี้...";
            }
          }
        }
        function processTurnStart(char) {
          triggerPassive(char, "onTurnStart");
          if (hasStatus(char, "stun")) {
            logAction(
              `😵 ${char.name} ติดสถานะมึนงงและข้ามเทิร์นนี้ไป!`,
              "log-info"
            );
            setTimeout(endTurn, 1500);
            return;
          }
          if (!char.isPlayer) {
            setTimeout(() => {
              const action = aiTurn();
              if (action) {
                gameState.actionQueue.push(action);
                processNextAction();
              } else {
                endTurn();
              }
            }, 1200);
          }
        }
        function applyEffect(
          caster,
          target,
          effect,
          isUltimate = false,
          originalCaster
        ) {
          const finalTarget =
            effect.recipient === "caster" ? originalCaster : target;
          let damageDealt = 0;
          if (effect.chance && Math.random() > effect.chance) {
            return 0;
          }
          switch (effect.type) {
            case "damage":
              damageDealt = applyDamage(
                caster,
                finalTarget,
                effect.value,
                effect.bypassCritAndEvade
              );
              break;
            case "heal":
              let healAmount = effect.value;
              if (gameState.currentEnvironment.id === "sacred_ground") {
                healAmount = Math.round(healAmount * 1.25);
                logAction(
                  "✨ ผลของพื้นที่ศักดิ์สิทธิ์ทำให้การฮีลแรงขึ้น!",
                  "log-info"
                );
              }
              heal(finalTarget, healAmount);
              break;
            case "applyStatus":
              applyStatus(finalTarget, effect.statusType, effect.duration);
              break;
            case "lifesteal":
              const amountToHeal = Math.round(effect.baseValue * effect.ratio);
              heal(caster, amountToHeal);
              logAction(
                `🩸 ${caster.name} ได้รับพลังชีวิต ${amountToHeal} จากสกิลติดตัว!`,
                "log-heal"
              );
              break;
            case "lifesteal_damage":
              const dealt = applyDamage(caster, target, effect.value);
              heal(caster, dealt);
              damageDealt = dealt;
              break;
            case "cleanse":
              removeRandomStatus(caster, effect.count, true);
              break;
            case "extraDamageOnBleed":
              if (hasStatus(target, "bleed")) {
                const extraDamage = effect.value;
                let logMsg = isUltimate
                  ? `🩸 ${caster.name} ฉีกบาดแผลของ ${target.name} สร้างความเสียหายมหาศาล ${extraDamage}!`
                  : `🔪 ${caster.name} โจมตีซ้ำที่แผลของ ${target.name} แรงขึ้น ${extraDamage}!`;
                logAction(logMsg, "log-damage");
                damageDealt += applyDamage(caster, target, extraDamage, true);
              }
              break;
            case "stealBuffs":
              const buffs = target.statuses.filter((s) =>
                GAME_CONSTANTS.BUFF_TYPES.includes(s.type)
              );
              if (buffs.length > 0) {
                buffs.forEach((buff) => {
                  removeStatus(target, buff.type, false);
                  applyStatus(caster, buff.type, buff.duration);
                  if (buff.type === "shield") {
                    caster.shield += target.shield;
                    target.shield = 0;
                  }
                });
                logAction(
                  `✨ ${caster.name} ขโมยบัฟจาก ${target.name}!`,
                  "log-status"
                );
              } else {
                logAction(`🤷 ${target.name} ไม่มีบัฟให้ขโมย!`, "log-info");
              }
              break;
            case "healLowestAlly":
              const allies = gameState.characters.filter(
                (c) => c.id !== caster.id && c.hp > 0 && c.team === caster.team
              );
              if (allies.length > 0) {
                allies.sort((a, b) => a.hp - b.hp);
                const lowestAlly = allies[0];
                heal(lowestAlly, effect.value);
                logAction(
                  `💖 ${caster.name} ฮีล ${lowestAlly.name} อย่างไม่ตั้งใจ!`,
                  "log-heal"
                );
              }
              break;
            case "swapHpPercentage":
              const casterHpPercent = caster.hp / caster.maxHp;
              const targetHpPercent = target.hp / target.maxHp;
              caster.hp = Math.round(targetHpPercent * caster.maxHp);
              target.hp = Math.round(casterHpPercent * target.maxHp);
              logAction(
                `💫 ${caster.name} และ ${target.name} สลับเปอร์เซ็นต์ HP กัน!`,
                "log-status"
              );
              break;
            case "applyShield":
              applyShield(finalTarget, effect.value);
              break;
            case "tauntHighestHpEnemy":
              const enemies = gameState.characters.filter(
                (c) => c.hp > 0 && c.team !== caster.team
              );
              if (enemies.length > 0) {
                enemies.sort((a, b) => b.hp - a.hp);
                applyStatus(enemies[0], "taunt", effect.duration);
              }
              break;
            case "hpStealPercentage":
              const stealAmount = Math.round(target.hp * effect.value);
              applyDamage(caster, target, stealAmount, true); // Bypass evade for steal
              heal(caster, stealAmount);
              logAction(
                `🩸 ${caster.name} ดูดพลังชีวิต ${stealAmount} หน่วยจาก ${target.name}!`,
                "log-heal"
              );
              break;
            case "transform":
              if (caster.id === "title" && !caster.transformed) {
                caster.transformed = true;

                const cardElement = document.getElementById(
                  `card-${caster.id}`
                );
                if (cardElement && caster.transformedImg) {
                  const imgWrapper = cardElement.querySelector(
                    ".char-image-wrapper"
                  );
                  const originalImg = imgWrapper.querySelector("img");

                  const newImg = document.createElement("img");
                  newImg.src = caster.transformedImg;
                  newImg.className = "transformed-img";
                  imgWrapper.appendChild(newImg);

                  cardElement.classList.add("is-transforming");

                  // --- แก้ไขส่วนนี้ ---
                  setTimeout(() => {
                    originalImg.remove(); // นำรูปเก่าออก
                    newImg.classList.remove("transformed-img"); // ทำให้รูปใหม่เป็นรูปหลัก (เอาคลาสพิเศษออก)
                    cardElement.classList.remove("is-transforming"); // จบสถานะอนิเมชั่น
                  }, 1500); // ปรับเวลาให้ตรงกับอนิเมชั่นใหม่ (1.5 วินาที)
                  // --- จบส่วนที่แก้ไข ---
                }

                if (
                  !caster.originalSkills ||
                  caster.originalSkills.length === 0
                ) {
                  caster.originalSkills = JSON.parse(
                    JSON.stringify(caster.skills)
                  );
                }
                caster.skills.splice(1, 2, ...caster.transformedSkills);
                logAction(
                  `✨ ${caster.name} ได้ปลดปล่อยพลังที่แท้จริง! เปลี่ยนเป็นร่างใหม่!`,
                  "log-ultimate"
                );
              }
              break;
          }
          return damageDealt;
        }
        function applyStatus(target, type, duration) {
          if (type === "defenseUp") removeStatus(target, "defenseDown", false);
          if (type === "defenseDown") removeStatus(target, "defenseUp", false);
          const existingStatus = target.statuses.find((s) => s.type === type);
          if (existingStatus) {
            existingStatus.duration = Math.max(
              existingStatus.duration,
              duration
            );
          } else {
            target.statuses.push({ type, duration });
          }
          logAction(`✨ ${target.name} ติดสถานะ '${type}'!`, "log-status");
        }
        function applyShield(target, amount) {
          target.shield += amount;
          if (!hasStatus(target, "shield")) {
            applyStatus(target, "shield", 99);
          }
          logAction(
            `🛡️ ${target.name} ได้รับโล่ป้องกัน ${amount} หน่วย!`,
            "log-shield"
          );
        }
        function aiTurn() {
          const aiChar = gameState.characters[gameState.currentPlayerIndex];
          const isSilenced = hasStatus(aiChar, "silenced");
          const getEnemies = () =>
            gameState.characters.filter(
              (char) => char.hp > 0 && char.team !== aiChar.team
            );
          const getAllies = () =>
            gameState.characters.filter(
              (char) => char.hp > 0 && char.team === aiChar.team
            );
          let possibleTargets = getEnemies();
          if (possibleTargets.length === 0) return null;
          const taunter = possibleTargets.find((t) => hasStatus(t, "taunt"));
          if (taunter) {
            possibleTargets = [taunter];
          }
          const availableSkills = aiChar.skills
            .map((skill, index) => ({ ...skill, index }))
            .filter(
              (skill) =>
                skill &&
                ((skill.isUltimate &&
                  aiChar.ultimateCharge >=
                    GAME_CONSTANTS.MAX_ULTIMATE_CHARGE) ||
                  (!skill.isUltimate &&
                    aiChar.energy >= skill.cost &&
                    aiChar.skillCooldowns[skill.index] === 0 &&
                    (!isSilenced || skill.isBasicAttack)))
            );
          const ultimateSkill = availableSkills.find((s) => s.isUltimate);
          if (ultimateSkill) {
            if (
              (ultimateSkill.target === "all_allies" ||
                ultimateSkill.target === "self") &&
              getAllies().some((a) => a.hp < a.maxHp * 0.5)
            ) {
              return { caster: aiChar, skill: ultimateSkill };
            }
            if (
              ultimateSkill.target === "single" ||
              ultimateSkill.target === "all_enemies"
            ) {
              const target = findBestOffensiveTarget(aiChar, possibleTargets);
              return {
                caster: aiChar,
                skill: ultimateSkill,
                preselectedTarget: target,
              };
            }
          }
          if (aiChar.hp < aiChar.maxHp * 0.5) {
            const defensiveSkills = availableSkills.filter(
              (s) =>
                !s.isUltimate &&
                (s.target === "self" || s.target === "all_allies") &&
                s.effects.some(
                  (e) =>
                    e.type === "heal" ||
                    e.type === "applyShield" ||
                    (e.type === "applyStatus" && e.statusType === "defenseUp")
                )
            );
            if (defensiveSkills.length > 0) {
              defensiveSkills.sort(
                (a, b) => (b.effects[0].value || 0) - (a.effects[0].value || 0)
              );
              return { caster: aiChar, skill: defensiveSkills[0] };
            }
          }
          const offensiveSkills = availableSkills.filter(
            (s) =>
              !s.isUltimate &&
              (s.target === "single" || s.target === "all_enemies")
          );
          if (offensiveSkills.length > 0) {
            const skillToUse =
              offensiveSkills[
                Math.floor(Math.random() * offensiveSkills.length)
              ];
            let target = null;
            if (skillToUse.target === "single") {
              target = findBestOffensiveTarget(aiChar, possibleTargets);
            }
            return {
              caster: aiChar,
              skill: skillToUse,
              preselectedTarget: target,
            };
          }
          const basicAttack = availableSkills.find((s) => s.isBasicAttack);
          if (basicAttack) {
            const target = findBestOffensiveTarget(aiChar, possibleTargets);
            return {
              caster: aiChar,
              skill: basicAttack,
              preselectedTarget: target,
            };
          }
          logAction(`🤔 ${aiChar.name} ทำอะไรไม่ได้!`, "log-info");
          return null;
        }
        function findBestOffensiveTarget(caster, possibleTargets) {
          if (Math.random() < 0.7) {
            possibleTargets.sort((a, b) => a.hp - b.hp);
            return possibleTargets[0];
          } else {
            const randomIndex = Math.floor(
              Math.random() * possibleTargets.length
            );
            return possibleTargets[randomIndex];
          }
        }
        function handleStatusEffectsAtTurnEnd(char) {
          if (hasStatus(char, "bleed")) {
            logAction(
              `🩸 ${char.name} ได้รับความเสียหาย ${GAME_CONSTANTS.BLEED_DAMAGE} จากสถานะเลือดออก!`,
              "log-damage"
            );
            applyDamage(char, char, GAME_CONSTANTS.BLEED_DAMAGE, true);
          }
          if (gameState.currentEnvironment.id === "magnetic_field") {
            logAction(
              `📉 ผลของสนามแม่เหล็กทำให้ ${char.name} เสีย 5 Energy!`,
              "log-info"
            );
            char.energy = Math.max(0, char.energy - 5);
          }
          char.statuses.forEach((s) => s.duration--);
          const expiredStatuses = char.statuses.filter((s) => s.duration <= 0);
          expiredStatuses.forEach((s) =>
            logAction(
              `👍 ${char.name} หายจากสถานะ '${s.type}' แล้ว`,
              "log-info"
            )
          );
          char.statuses = char.statuses.filter((s) => s.duration > 0);
          char.energy = Math.min(
            char.maxEnergy,
            char.energy + GAME_CONSTANTS.TURN_END_ENERGY_REGEN
          );
        }
        function removeRandomStatus(char, count, log = false) {
          const debuffs = char.statuses.filter(
            (s) => !GAME_CONSTANTS.BUFF_TYPES.includes(s.type)
          );
          for (let i = 0; i < count; i++) {
            if (debuffs.length > 0) {
              const randomIndex = Math.floor(Math.random() * debuffs.length);
              const removed = debuffs.splice(randomIndex, 1)[0];
              removeStatus(char, removed.type, log);
            }
          }
        }
        function hasStatus(char, type) {
          return char.statuses.some((s) => s.type === type);
        }
        function removeStatus(char, type, log = true) {
          const statusIndex = char.statuses.findIndex((s) => s.type === type);
          if (statusIndex > -1) {
            const removed = char.statuses.splice(statusIndex, 1);
            if (log)
              logAction(
                `👍 ${char.name} ไม่ติดสถานะ '${removed[0].type}' อีกต่อไปแล้ว`,
                "log-info"
              );
          }
          if (type === "shield") {
            char.shield = 0;
          }
        }
        function tickDownCooldowns(char) {
          if (!char) return;
          char.skillCooldowns = char.skillCooldowns.map((cd) =>
            Math.max(0, cd - 1)
          );
        }
        function triggerPassive(caster, triggerType, context = {}) {
          if (
            !caster.passive ||
            !caster.passive.trigger || // Check if trigger exists
            caster.passive.trigger !== triggerType ||
            hasStatus(caster, "passiveSeal")
          )
            return;
          // Puthai's passive is handled directly in applyDamage, so we skip it here.
          if (caster.id === "puthai") return;

          const passive = caster.passive;
          if (
            passive.condition &&
            passive.condition === "isBasicAttack" &&
            !context.isBasicAttack
          )
            return;
          const chance = passive.chance || 1;
          if (Math.random() < chance) {
            logAction(
              `💡 สกิลติดตัวของ ${caster.name} (${passive.name}) ทำงาน!`,
              "log-info"
            );
            let effectWithContext = { ...passive.effect };
            if (
              passive.effect.type === "lifesteal" ||
              passive.effect.type === "extraDamageOnBleed"
            ) {
              effectWithContext.baseValue = context.damageDealt;
            }
            applyEffect(caster, context.target || caster, effectWithContext);
          }
        }
        function selectTarget(possibleTargets) {
          DOM.targetModal.classList.remove("hidden");
          const targetOptions = document.getElementById("target-options");
          targetOptions.innerHTML = "";
          return new Promise((resolve) => {
            possibleTargets.forEach((target) => {
              const button = document.createElement("button");
              button.className =
                "target-button glass-ui border-2 border-cyan-700/50 rounded-lg p-3 text-left cursor-pointer transition-all duration-200 hover:border-cyan-400 hover:scale-105";
              const statusIcons = target.statuses
                .map(
                  (s) =>
                    `<div class="w-5 h-5 bg-gray-500 rounded-full text-xs flex items-center justify-center" title="${
                      s.type
                    }">${s.type.slice(0, 2).toUpperCase()}</div>`
                )
                .join("");
              button.innerHTML = ` <div class="flex items-center gap-3 sm:gap-4"> <img src="${
                target.img
              }" class="w-14 h-14 sm:w-16 sm:h-16 rounded-lg object-cover border-2 border-cyan-700/50" onerror="this.onerror=null;this.src='https://placehold.co/64x64/0c1735/FFFFFF?text=${target.name.slice(
                0,
                1
              )}';"> <div> <h4 class="font-orbitron text-base sm:text-lg text-white">${
                target.name
              }</h4> <p class="text-sm text-green-400">HP: ${target.hp}/${
                target.maxHp
              }</p> <div class="flex gap-1 mt-1">${statusIcons}</div> </div> </div>`;
              button.onclick = () => {
                sfx.play("click");
                hideAllModals();
                resolve([target]);
              };
              targetOptions.appendChild(button);
            });
            DOM.cancelTargetSelectionButton.onclick = () => {
              sfx.play("click");
              hideAllModals();
              resolve(null);
            };
          });
        }
        function hideAllModals() {
          DOM.allModals.forEach((m) => m.classList.add("hidden"));
        }
        async function showSkillActivationModal(caster, skill) {
          if (!skill.quote) return Promise.resolve();
          return new Promise((resolve) => {
            // --- แก้ไขส่วนนี้ ---
            let imageUrl = caster.img; // ใช้รูปปกติเป็นค่าเริ่มต้น
            if (caster.id === "title" && caster.transformed) {
              imageUrl = caster.transformedImg; // ถ้าร่างแปลง ให้เปลี่ยนเป็นรูปใหม่
            }
            // --- จบส่วนที่แก้ไข ---

            DOM.skillModal.classList.remove("hidden");
            DOM.skillModal.querySelector("#skill-modal-img").src = imageUrl; // ใช้ตัวแปร imageUrl ที่กำหนดไว้
            DOM.skillModal.querySelector("#skill-modal-char-name").textContent =
              caster.name;
            DOM.skillModal.querySelector(
              "#skill-modal-quote"
            ).textContent = `"${skill.quote}"`;
            setTimeout(() => {
              hideAllModals();
              resolve();
            }, 2500);
          });
        }
        async function playAttackAnimation(caster, targets) {
          const casterCard = document.getElementById(`card-${caster.id}`);
          if (casterCard) {
            casterCard.style.zIndex = "100";
            casterCard.classList.add("scale-110");
          }
          await new Promise((r) => setTimeout(r, 200));
          targets.forEach((target) => {
            const targetCard = document.getElementById(`card-${target.id}`);
            if (targetCard) targetCard.classList.add("taking-damage");
          });
          await new Promise((r) => setTimeout(r, 400));
          if (casterCard) {
            casterCard.style.zIndex = "1";
            casterCard.classList.remove("scale-110");
          }
          targets.forEach((target) => {
            const targetCard = document.getElementById(`card-${target.id}`);
            if (targetCard) targetCard.classList.remove("taking-damage");
          });
        }
        function showHitEffect(card, text, type = "damage") {
          if (!card) return;
          const hitEffect = document.createElement("div");
          const colorClass =
            type === "crit"
              ? "text-amber-300 text-5xl font-bold"
              : type === "heal"
              ? "text-green-400 text-4xl"
              : "text-red-400 text-4xl";
          hitEffect.className = `hit-effect absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none z-[200] ${colorClass}`;
          hitEffect.style.textShadow = "1px 1px 8px black";
          hitEffect.textContent = text;
          const container = card.querySelector(".char-image-container");
          if (container) {
            container.appendChild(hitEffect);
            setTimeout(() => hitEffect.remove(), 1500);
          }
        }
        function showTurnIndicator(name, isPlayer) {
          const turnText = DOM.turnIndicator.querySelector("#turn-text");
          DOM.turnIndicator.classList.remove("opacity-0");
          turnText.textContent = isPlayer
            ? `Your Turn: ${name}`
            : `${name}'s Turn`;
          DOM.turnIndicator.style.borderColor = isPlayer
            ? "rgb(0 229 255)"
            : "rgb(255 65 108)";
          setTimeout(() => DOM.turnIndicator.classList.add("opacity-0"), 2200);
        }
        function handleWhirlwind() {
          logAction("🌪️ พายุหมุนพัดเข้ามาในสนามรบ!", "log-turn");
          const aliveChars = gameState.characters
            .map((c, i) => ({ ...c, originalIndex: i }))
            .filter((c) => c.hp > 0);
          if (aliveChars.length < 2) return;
          const index1 = Math.floor(Math.random() * aliveChars.length);
          let index2 = Math.floor(Math.random() * aliveChars.length);
          while (index1 === index2) {
            index2 = Math.floor(Math.random() * aliveChars.length);
          }
          const char1 = aliveChars[index1];
          const char2 = aliveChars[index2];
          logAction(
            `🌪️ ${char1.name} และ ${char2.name} ถูกพายุพัดสลับตำแหน่งกัน!`,
            "log-info"
          );
          const temp = gameState.characters[char1.originalIndex];
          gameState.characters[char1.originalIndex] =
            gameState.characters[char2.originalIndex];
          gameState.characters[char2.originalIndex] = temp;
          DOM.cardArea.innerHTML = "";
          gameState.characters.forEach(createCharacterCard);
          add3dHoverEffect("#card-area");
          updateAllUI();
        }
        function checkGameOver() {
          let isOver = false;
          if (gameState.gameMode === "2v2") {
            const team1Alive = gameState.characters.some(
              (c) => c.team === 1 && c.hp > 0
            );
            const team2Alive = gameState.characters.some(
              (c) => c.team === 2 && c.hp > 0
            );
            if (!team1Alive || !team2Alive) {
              const player = findCharacter(gameState.selectedPlayerId);
              const playerTeamWon = player
                ? (player.team === 1 && team1Alive) ||
                  (player.team === 2 && team2Alive)
                : team1Alive;
              showGameOver(playerTeamWon);
              isOver = true;
            }
          } else {
            const aliveCharacters = gameState.characters.filter(
              (c) => c.hp > 0
            );
            if (aliveCharacters.length <= 1) {
              const winner =
                aliveCharacters.length === 1 ? aliveCharacters[0] : null;
              showGameOver(winner);
              isOver = true;
            }
          }
          return isOver;
        }
        function findCharacter(id) {
          return gameState.characters.find((c) => c.id === id);
        }
        function generateSkillEffectDescription(skill) {
          if (!skill || !skill.effects || skill.effects.length === 0)
            return "สกิลนี้ไม่มีผลอะไรเป็นพิเศษ";
          return skill.effects
            .map((effect) => {
              switch (effect.type) {
                case "damage":
                  let desc = `สร้างความเสียหาย ${effect.value} หน่วย`;
                  if (effect.recipient === "caster") desc += `แก่ตัวเอง`;
                  return desc;
                case "heal":
                  return `ฟื้นฟู HP ${effect.value} หน่วย`;
                case "applyStatus":
                  return `ทำให้เป้าหมายติดสถานะ '${effect.statusType}' ${
                    effect.duration
                  } เทิร์น${
                    effect.chance < 1
                      ? ` (มีโอกาส ${effect.chance * 100}%)`
                      : ""
                  }`;
                case "stealBuffs":
                  return `ขโมยสถานะเสริมทั้งหมดจากเป้าหมาย`;
                case "lifesteal_damage":
                  return `สร้างความเสียหาย ${effect.value} หน่วยและฟื้นฟู HP 100% ของความเสียหายที่ทำ`;
                case "swapHpPercentage":
                  return `สลับเปอร์เซ็นต์ HP กับเป้าหมาย`;
                case "applyShield":
                  return `สร้างโล่ ${effect.value} หน่วย`;
                case "hpStealPercentage":
                  return `ขโมย HP ${
                    effect.value * 100
                  }% ของ HP ปัจจุบันของเป้าหมาย`;
                default:
                  return "ผลพิเศษ";
              }
            })
            .join(" และ ");
        }

        const itemDefinitions = {
          potion: {
            name: "ยาฟื้นฟู",
            description: "ฟื้นฟู HP 50 หน่วยให้เป้าหมายฝ่ายเรา",
            target: "ally",
          },
          bomb: {
            name: "ระเบิด",
            description: "สร้างความเสียหาย 40 หน่วยให้เป้าหมายศัตรู",
            target: "enemy",
          },
        };

        function openItemModal() {
          DOM.itemGrid.innerHTML = "";
          const inventory = gameState.playerData.inventory;

          for (const itemId in inventory) {
            if (inventory[itemId] > 0) {
              const itemDef = itemDefinitions[itemId];
              const itemEl = document.createElement("button");
              itemEl.className =
                "glass-ui p-4 rounded-lg text-center flex flex-col items-center justify-between hover:border-yellow-400 transition-all disabled:opacity-50 disabled:cursor-not-allowed";
              itemEl.disabled =
                !gameState.isPlayerTurn ||
                gameState.itemUsedThisTurn ||
                gameState.isActionInProgress;
              itemEl.innerHTML = `
                            <div class="font-bold text-yellow-300 text-lg">${itemDef.name}</div>
                            <div class="text-xs my-2">${itemDef.description}</div>
                            <div class="text-xl font-orbitron">x${inventory[itemId]}</div>
                        `;
              itemEl.onclick = () => useItem(itemId, itemDef.target);
              DOM.itemGrid.appendChild(itemEl);
            }
          }
          DOM.itemModal.classList.remove("hidden");
        }

        async function useItem(itemId, targetType) {
          sfx.play("item");
          DOM.itemModal.classList.add("hidden");

          let possibleTargets = [];
          if (targetType === "ally") {
            possibleTargets = gameState.characters.filter(
              (c) =>
                c.team === findCharacter(gameState.selectedPlayerId).team &&
                c.hp > 0
            );
          } else {
            // 'enemy'
            possibleTargets = gameState.characters.filter(
              (c) =>
                c.team !== findCharacter(gameState.selectedPlayerId).team &&
                c.hp > 0
            );
          }

          const targets = await selectTarget(possibleTargets);
          if (!targets || targets.length === 0) {
            logAction("ยกเลิกการใช้ไอเทม", "log-info");
            return;
          }
          const target = targets[0];

          gameState.playerData.inventory[itemId]--;
          gameState.itemUsedThisTurn = true;
          logAction(
            `ผู้เล่นใช้ ${itemDefinitions[itemId].name} ใส่ ${target.name}!`,
            "log-status"
          );

          // Apply item effect
          if (itemId === "potion") {
            heal(target, 50);
          } else if (itemId === "bomb") {
            applyDamage(null, target, 40, true);
          }

          updateAllUI();
          setTimeout(endTurn, 1000);
        }

        function setupItemModal() {
          DOM.itemButton.addEventListener("click", () => {
            sfx.play("click");
            openItemModal();
          });
          DOM.closeItemModalButton.addEventListener("click", () => {
            sfx.play("click");
            DOM.itemModal.classList.add("hidden");
          });
        }

        DOM.restartGameButton.addEventListener("click", () => {
          sfx.play("click");
          hideAllModals();
          DOM.gameProper.classList.add("hidden");
          setupModeSelection();
        });
        DOM.startGameButton.addEventListener("click", () => {
          sfx.play("click");
          if (gameState.selectedPlayerId) {
            DOM.characterSelectionScreen.classList.add("hidden");
            DOM.loadingScreen.classList.remove("hidden", "opacity-0");
            setTimeout(() => initGame(gameState.selectedPlayerId), 500);
          }
        });

        // This is the main entry point
        async function main() {
          DOM.loadingScreen.classList.remove("hidden", "opacity-0");
          // The game will now use the default inventory defined in gameState
          // and will not save progress.
          await new Promise((r) => setTimeout(r, 200)); // Simulate loading
          DOM.loadingScreen.classList.add("hidden", "opacity-0");
          setupModeSelection();
          setupTutorialModal();
          setupItemModal();
        }

        main();
      });
    </script>
  </body>
</html>
